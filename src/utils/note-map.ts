// Auto-generated, DO NOT EDIT MANUALLY

export const notesData = {
  "阻止页面关闭": {
    "content": "\n# 阻止页面关闭\n\nThis is the content of 阻止页面关闭.\n\n### 使用 beforeunload 事件，结合 preventDefault() 和 returnValue\n```js\nwindow.onbeforeunload = (event) => {\n  // 必须调用 preventDefault() 和设置 returnValue\n  event.preventDefault()\n  event.returnValue = '' // 旧版浏览器需要\n  return '' // 部分浏览器可能忽略返回值\n}\n```\n慎用场景：频繁弹窗可能导致用户体验下降，建议仅在数据可能丢失时使用。\n",
    "data": {
      "Created At": "8/1/2025, 4:22:53 PM",
      "Updated At": "8/1/2025, 4:22:53 PM",
      "File Name": "阻止页面关闭",
      "Path": "src/notes/borswer/阻止页面关闭.md",
      "Tag": "borswer"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "PicTagTextEditor组件的封装": {
    "content": "\n# [PicTagTextEditor 组件封装 (vue3 版本)](https://github.com/FU-design/Picture/tree/main/src/components/PicTagTextEditor)\n\n#### 功能点\n- 类似于表单控件中的输入框，**可输入文本内容**\n- 可在输入框中 **添加 tag** (不是文本的 dom 元素内容)\n- 可通过获取焦点时，通过 **光标控制** 添加 tag 时在输入框中 **添加的位置**\n\n## 实现前的准备工作\n\n> 实现该组件还需要了解如下  **DOM属性** 和 **Web API** 以及 **CSS** 相关特性\n\n### DOM 属性\n  - [contenteditable](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/contenteditable): 使用 `contenteditable` 属性让普通元素拥有类似输入框的特性\n  - [data-\\*（全局属性）](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/data-*): **自定义数据属性**的属性，可以通过脚本在 HTML 与 DOM 表示之间进行专有**数据的交换**\n\n### CSS 属性\n  - [attr 函数](https://developer.mozilla.org/zh-CN/docs/Web/CSS/attr)\n  - [:focus-within 伪类](https://developer.mozilla.org/en-US/docs/Web/CSS/:focus-within)\n  - [white-space](https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space)\n  - [word-break](https://developer.mozilla.org/zh-CN/docs/Web/CSS/word-break)\n  - [overflow-wrap](https://developer.mozilla.org/zh-CN/docs/Web/CSS/overflow-wrap)\n\n### Web API\n\n#### [Selection](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection)\n\n表示用户选择的文本及其范围。\n\n```js\nconst selection = window.getSelection()\n```\n\n`Selection` 对象的部分方法：\n  - `getRangeAt`: 返回一个包含当前选区内容的区域对象。\n  - `addRange(range)`: 将一个 `Range` 对象添加到选定范围中。\n  - `removeAllRanges()`: 移除所有选定范围。\n\n#### [Range](https://developer.mozilla.org/zh-CN/docs/Web/API/Range)\n\n表示一个包含节点与文本节点的一部分的文档片段。\n\n获取 `Range` 对象的主要方法：\n\n  ```js\n  const range0 = document.createRange()\n\n  // Selection 对象的 getRangeAt() 方法\n  const range1 = window.getSelection()?.getRangeAt(0)\n\n  // 通过构造函数获取\n  const range2 = new Range()\n  ```\n\n`Range` 对象的部分方法：\n\n- `collapse(toStart)`: 折叠选区，`toStart` 为 `true` 时折叠到起始位置，为 `false`时折叠到结束位置。\n- `insertNode(node)`: 在 `Range` 的起始位置插入一个节点。\n- `setStartAfter(node)`: 用于将 `Range` 的起始位置设置在指定 node 之后。即，范围从所指定节点的下一个位置开始。\n\n#### [MutationObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)\n\n接口提供了监视对 DOM 树所做更改的能力,是 DOM3 Events 规范的一部分。（可前往官网查看使用方式）\n\n## 开始实现\n\n### 创建编辑器的主体\n\n为作为 **可编辑容器** 的 DOM 添加属性 `contenteditable`，让其拥有表单元素的部分特性。\n```html\n <div class=\"tag-text-editor-wrp\">\n    <div :contenteditable=\"true\"/>\n  </div>\n```\n### 实现编辑器的 placeholder 属性\n\n当我为其添加 `placeholder` 这个属性的时候，会发现是 **无效** 的，原来这一点是 contenteditable 属性没有从表单元素中继承到的，因此需要来手动实现。这就需要用到 `data-*` 全局属性配合 `attr` 函数以及 `::before` 伪元素来模拟实现。具体代码如下：\n```html\n <div class=\"tag-text-editor-wrp\">\n    <div\n      class=\"tag-text-editor\"\n      data-placeholder=\"Please input ....\"\n      :contenteditable=\"true\"\n    />\n  </div>\n```\n```css\n.tag-text-editor::before{\n  content: attr(data-placeholder);\n  color: var(--input-placeholder); /* 自定义css变量 */\n  cursor: text; /* 统一鼠标的 hover 外形是对文本操作的  */\n\n  /* placeholder 文本超出容器时做省略处理 */\n  display: block;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n```\n效果如下：\n\n![01](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExZXkwZ3pubmhwaTJsZHg1czcyOHVxOGU4NnZxejY3N3oxZ3RmMWducSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/aylLhEhnRP8QEFLfV6/giphy.gif)\n\n### 实现 tag 元素的创建\n\n在实现之前，先定义编辑器内容的数据结构，方便数据转化时的对外统一。\n```ts\nexport type CreateType = 'tag' | 'text'\n\nexport interface ContentItem {\n  type: CreateType\n  text: string\n  [propName: string]: unknown\n}\n\nexport interface TagTextEditorProps {\n  uid: string\n  contents: ContentItem[]\n  disabled?: boolean\n  placeholder?: string\n}\n```\n创建 **usePicTagTextEditor.ts** 组合式函数, 直接上代码\n\n```ts\nimport type { ContentItem, CreateType } from './type'\nimport { ref, shallowRef } from 'vue'\n\nexport function usePicTagTextEditor() {\n  const tagTextEditorRef = ref<HTMLElement>()\n  const contentTypeMap = shallowRef<Record<CreateType, (contentItem: ContentItem) => Node>>({\n    tag: (contentItem: ContentItem) => createTag(contentItem),\n    text: (contentItem: ContentItem) => createText(contentItem),\n  })\n\n  // 创建文本元素\n  function createText(contentItem?: ContentItem) {\n    return document.createTextNode(contentItem ? contentItem.text ?? '' : '')\n  }\n\n  // 我这里使用的是 I 标签作为 tag 的载体\n  function createTag(contentItem: ContentItem) {\n    const fragment = document.createDocumentFragment()\n    const tag = document.createElement('i')\n\n    // 子元素会继承父元素的 contenteditable，所以这里要重置一下\n    tag.setAttribute('contenteditable', 'false')\n    tag.classList.add('tag')\n    tag.textContent = contentItem.text\n    fragment.appendChild(tag)\n    return fragment\n  }\n\n  function createContent(contentItem: ContentItem) {\n    return contentTypeMap.value[contentItem.type](contentItem)\n  }\n\n  return {\n    tagTextEditorRef,\n    createText,\n    createTag,\n    insertTag,\n    createContent,\n  }\n}\n```\n在 **PicTagTextEditor.vue** 组件中使用\n```ts\n// PicTagTextEditor.vue\n\nimport type { ContentItem, TagTextEditorEmits, TagTextEditorProps } from './type'\nimport { usePicTagTextEditor } from './usePicTagTextEditor'\nconst { tagTextEditorRef, createText, createContent, } = usePicTagTextEditor()\n\n// 初始化编辑器内容\nfunction setupContents() {\n  if (props.contents.length <= 0) {\n    return\n  }\n  const fragment = document.createDocumentFragment()\n  for (const content of props.contents) {\n    fragment.appendChild(createContent(content))\n  }\n  tagTextEditorRef.value?.appendChild(fragment)\n}\n```\n```html\n <div class=\"tag-text-editor-wrp\">\n    <div\n      ref=\"tagTextEditorRef\"\n      class=\"tag-text-editor\"\n      :data-placeholder=\"$props.placeholder\"\n      :contenteditable=\"!$props.disabled\"\"\n    />\n  </div>\n```\n使用模拟数据在组件 `PicTagTextEditor` 的生命周期函数 `onMounted` 进行初始化\n```ts\n// PicTagTextEditor_test.vue\n\nimport type { ContentItem } from '@/components/PicTagTextEditor/type'\nimport PicTagTextEditor from '@/components/PicTagTextEditor/index.vue'\nimport { reactive, ref } from 'vue'\n\nconst picTagTextEditorRef = ref<InstanceType<typeof PicTagTextEditor>>()\nconst data = reactive<ContentItem[]>([ // 模拟数据\n  {\n    type: 'tag',\n    text: 'welcome world!',\n  },\n  {\n    type: 'text',\n    text: 'hello',\n  },\n  {\n    type: 'tag',\n    text: 'I’am fine, thank you!',\n  },\n])\n```\n```html\n <div class=\"picTag-text-editor_test\">\n   <PicTagTextEditor\n    ref=\"picTagTextEditorRef\"\n    v-model:contents=\"data\"\n  />\n </div>\n```\n\n渲染结果如下：\n\n![02](https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExMWlkMnBtYjF3ajg2eDRycGF5ZnB0ZnA0ZnB4NWIyZGZjdmwxcTI5dSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/7ikKbijW40BY6VWWSd/giphy.gif)\n\n到这里组件的 **基本结构** 就实现完成了，下面就是主要的插入 **tag** 操作。\n\n### 实现如何将 tag 插入到编辑器中光标所在位置\n\n在 **usePicTagTextEditor.ts** 文件中定义 **insertTag** 方法以及 `Range` 实例\n\n```ts\n// usePicTagTextEditor.ts\n\n// .... else .....\nconst range = shallowRef<Range>()\n\nfunction insertTag(item: ContentItem) {\n  if (!range.value) {\n    return\n  }\n  // 判断缓存的 range 信息中光标的最后落点元素是否为 tag 或其子孙元素\n  const el = range.value.commonAncestorContainer as Element\n  if (el?.closest && el?.closest('tag')) {\n    return\n  }\n  if (!el?.closest && el.parentElement?.closest('.tag')) {\n    return\n  }\n  const tag = createContent(item)\n  range.value.insertNode(tag) // 在当前光标的前面插入 tag 元素\n  range.value.collapse(false) // 合并光标的选取范围\n  resetSelectionCollapse(range.value)\n}\n\n// 重置光标位置\nfunction resetSelectionCollapse(range: Range) {\n  const selection = window.getSelection()\n  selection?.removeAllRanges()\n  selection?.addRange(range)\n  tagTextEditorRef.value?.focus()\n}\n\nreturn {\n  // .... else .....\n  range,\n  insertTag,\n  resetSelectionCollapse\n}\n```\n在 **PicTagTextEditor.vue** 文件中补充后，将 **insertTag** 方法直接 **暴露** 出去，供父组件调用。\n\n```ts\n// PicTagTextEditor.vue\n\ndefineExpose({\n  insertTag,\n})\n```\n\n在 **PicTagTextEditor_test.vue** 文件中使用 **insertTag** 方法\n\n```ts\n// .... else ......\nconst insertContent = ref('')\n\nfunction onInput(e: Event) {\n  insertContent.value = (e?.target as any).value ?? ''\n}\n\nfunction onInsert() {\n  if (insertContent.value === '') {\n    console.warn('插入内容不能为空！ :>> ')\n    return\n  }\n  picTagTextEditorRef.value.insertTag({ type: 'tag', text: insertContent.value })\n}\n```\n\n```html\n<div class=\"picTag-text-editor_test\">\n   <div>\n      <input placeholder=\"请输入插入到编辑器的内容\" @input=\"onInput\">\n      <button :border=\"true\" @click=\"onInsert\">\n        insert\n      </button>\n    </div>\n   <PicTagTextEditor\n    ref=\"picTagTextEditorRef\"\n    v-model:contents=\"data\"\n  />\n</div>\n```\n效果如下：\n\n![03](https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExbHc3bmV1b3oweGJmYjZta251ZHlpOGE0bGRsaWJkd2JwNjZqdDhyNCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/wMj1L2de6hnwarK2MI/giphy.gif)\n\n### 定义关于编辑器内容和数据绑定的变动同步\n\n对于绑定 `contenteditable` 属性为 **true** 的元素，会继承表单控件的一些 **事件**，这里用到了几个常用的事件对编辑器进行了绑定。\n\n```ts\n// PicTagTextEditor_test.vue\n\nexport type TagChangeCommad = 'add' | 'remove'\nexport interface TagTextEditorEmits {\n  (event: 'focus', e?: Event,): void\n  (event: 'blur', e?: Event,): void\n  (event: 'change', commad: TagChangeCommad, tag: ContentItem): void\n  (event: 'update:contents', contents: ContentItem[]): void\n}\n```\n其中主要的还是 **change** 和 **focus** 事件,两者配合 `MutationObserver` 实现未继承到的表单控件的 **change** 事件。（单纯的通过监听 **input** 事件，无法监听到从外部插入 **tag** 时编辑器的变动。 ）\n\n这里先对 `mutationObserver` 封装了一下（可不封装）：\n```ts\n// useMutationObserver.ts\n\nimport { reactive, type Ref, shallowRef } from 'vue'\n\ntype RequireAtLeastOne<\n  T,\n  Keys extends keyof T = keyof T,\n> = Partial<T> & {\n  [K in Keys]: Required<Pick<T, K>>\n}[Keys]\n\nexport type Callback = (mutations: MutationRecord, observer?: MutationObserver) => void\nexport type MutationCallbackMap = RequireAtLeastOne<Record<MutationRecordType, Callback>>\n\nexport function useMutationObserver(observerElementRef: Ref<HTMLElement | undefined>, mutationCallbackMap: MutationCallbackMap, options?: MutationObserverInit) {\n  const observer = shallowRef<MutationObserver>()\n  const observerOptions = reactive<MutationObserverInit>({\n    childList: false, // 监听 target 节点中发生的节点的新增与删除（同时，如果 subtree 为 true，会针对整个子树生效\n    characterData: false, // 监听声明的 target 节点上所有字符的变化\n    subtree: true, // 监听以 target 为根节点的整个子树\n  })\n\n  const handleObserver = (mutations: MutationRecord[], observer: MutationObserver) => {\n    mutations.forEach((mutation) => {\n      mutationCallbackMap[mutation.type]?.(mutation, observer)\n    })\n  }\n\n  // 初始化监听元素变动\n  const setupObserver = () => {\n    // merge options\n    for (const key of Object.keys(mutationCallbackMap) as MutationRecordType[]) {\n      observerOptions[key] = !!mutationCallbackMap[key]\n    }\n    // merge options\n    if (options) {\n      Object.assign(observerOptions, options)\n    }\n    observer.value = observer.value ?? new MutationObserver(handleObserver)\n    observer.value?.observe(observerElementRef.value!, observerOptions)\n  }\n\n  return {\n    observer,\n    setupObserver,\n  }\n}\n```\n\n在 **PicTagTextEditor.vue** 中使用\n\n```ts\n// PicTagTextEditor.vue\n\nconst { checkAncestorContainerAndCacheRange } = usePicTagTextEditor()\nconst { setupObserver } = useMutationObserver(tagTextEditorRef, {\n  childList: handleChildListChange,\n  characterData: handleCharacterDataChange,\n})\n\nfunction onFocus(e: Event) {\n  setupObserver()\n  emits('focus', e)\n}\n\nfunction onBlur(e: Event) {\n  checkAncestorContainerAndCacheRange()\n  emits('blur', e)\n}\n\n// 判断变动操作的类型（针对 tag 的变动）\nfunction handleChildListChange(mutation: MutationRecord) {\n  const { removedNodes, addedNodes } = mutation\n  const tagChangeCommad = (removedNodes.length > 0 ? 'remove' : 'add')\n  const tag = removedNodes.length > 0 ? removedNodes[0] : addedNodes[0]\n\n  // 过滤空字符串值\n  if (tag.textContent !== '') {\n    const tagContent: ContentItem = { type: 'tag', text: tag.textContent! }\n    emits('change', tagChangeCommad, tagContent)\n    emits('update:contents', getEditorContent())\n  }\n}\n\n// 文本字符的变动\nfunction handleCharacterDataChange() {\n  emits('update:contents', getEditorContent())\n}\n```\n\n在 **usePicTagTextEditor.ts** 中添加 **checkAncestorContainerAndCacheRange** 方法,用于在当前编辑器失去焦点的时候，缓存最后一次操作光标时的范围信息。以便在插入时直接使用该 **range** 信息,决定插入到编辑器内容中的位置。\n```ts\n// usePicTagTextEditor.ts\n\nfunction checkAncestorContainerAndCacheRange() {\n  const tempRange = window.getSelection()?.getRangeAt(0)\n  if (tempRange) {\n    const isChildForContainer = tagTextEditorRef.value?.contains(tempRange.commonAncestorContainer) ?? false\n    isChildForContainer && (range.value = getSelection()?.getRangeAt(0))\n  }\n}\n```\n\n### 编辑器内容获取和数据类型转化\n\n获取容器元素的子元素，然后遍历获取 `textContent` 的值，在组合先前定义的统一数据结构。\n```ts\n// PicTagTextEditor.vue\n\nfunction getEditorContent() {\n  const editorContent = [] as ContentItem[]\n  const nodeItems = Array.from(tagTextEditorRef.value?.childNodes || [])\n  for (const item of nodeItems) {\n    if (!item.textContent) {\n      continue\n    }\n    if (item.nodeType === Node.TEXT_NODE) {\n      editorContent.push({ type: 'text', text: item.textContent })\n    }\n    else {\n      editorContent.push({ type: 'tag', text: item.textContent })\n    }\n  }\n  return editorContent\n}\n```\n## 浏览器兼容性问题\n\n对于通用组件来说，解决浏览器的兼容性问题是无法避免的。首次实现该组件是在 **Chrome 浏览器** 下实现的，不存在问题；但在 **FireFox 浏览器** 中出现了很多兼容性问题。\n\n经过查阅资料总结了遇到的如下问题：\n\n- [❌] 编辑器光标的位置向下偏移\n- [❌] 无法在前后没有文本内容的 tag 前后插入光标\n- [❌] 当点击 tag 内部时，光标会在其内部的文本内容中显示\n\n#### **Firefox** 的文本框架（Text Frame）与光标定位 (Chat GPT 给我的回答)\n>\n> - Firefox 仅在有“文本框架”时绘制并定位插入点。当一个 inline 元素内 无任何文本且无尺寸 时，它不会生成框架，插入点也就“无处可落”[Bugzilla Main Page](https://bugzilla.mozilla.org/show_bug.cgi?id=389321&utm_source=chatgpt.com)。\n>\n> - 一旦该元素内部 存在文本节点，即使元素本身被设为 contenteditable=\"false\"，其子文本节点也会产生独立的文本框架，浏览器会允许将光标移动到这些框架之间（显示为可见的插入点），但输入仍不会改变它们的内容。[Bugzilla Main Page](https://bugzilla.mozilla.org/show_bug.cgi?id=1612076&utm_source=chatgpt.com)。\n\n### 解决这些问题：\n\n#### 编辑器光标的位置向下偏移\n\n![04](https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExenVlZHJsMzNkeXpqeGJkYjhtOWl3aGVzcWg1MmFrd2toczU3amxuMyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/354XzcOnivzza4mZqr/giphy.gif)\n\n这个比较好解决，我通过改变 CSS 即可实现\n\n```css\n.tag-text-editor {\n  position: relative;\n}\n\n.tag-text-editor::before{\n  position: absolute;\n}\n```\n\n#### 无法在前后没有文本内容的 tag 前后插入光标 & 当点击 tag 内部时，光标会在其内部的文本内容中显示\n\n```ts\n// tool.ts\n\n// 在该 tag 的后面插入占位元素，并重置光标的落点到占位元素中\nexport function controlCursorToBypassDefaultInput() {\n  const selection = window.getSelection()\n  let range = selection?.getRangeAt(0) || document.createRange()\n  const parentElement = range?.endContainer.parentElement\n  if (parentElement && [...parentElement.classList || []].includes('tag')) {\n    parentElement?.after(createPlaceholder())\n    selection?.removeAllRanges()\n    range = document.createRange()\n    range?.setStart(parentElement.nextSibling!, 0)\n    range.collapse()\n    selection?.addRange(range)\n  }\n  return range\n}\n\nfunction createPlaceholder() {\n  return document.createTextNode('')\n}\n\n// 判断当前所用的是什么浏览器\nexport function checkNavigatorUserAgent(userAgent: string) {\n  return navigator.userAgent.toLowerCase().includes(userAgent.toLowerCase())\n}\n\n// 在容器的首节点且不是文本节点的前面插入占位符（空格）\nexport function insertInputPlaceholder(container: HTMLElement) {\n  const childNodes = container!.childNodes\n  if (childNodes.length > 0) {\n    const firstChild = container?.firstChild\n    if (firstChild?.nodeType !== Node.TEXT_NODE) {\n      container?.insertBefore(createPlaceholder(), firstChild as Node)\n    }\n  }\n}\n```\n```ts\n// PicTagTextEditor.vue\n\nfunction onClick() {\n  // 确保点击不可编辑元素时调整光标并插入占位元素，从而绕过浏览器的渲染机制（兼容FireFox）\n  if (checkNavigatorUserAgent('firefox')) {\n    range.value = controlCursorToBypassDefaultInput()\n  }\n}\n\nfunction setupContents() {\n  // ... else ...\n  const fragment = document.createDocumentFragment()\n  // 确保容器的第一个子元素为文本 => 占位元素 (兼容 FireFox)\n  checkNavigatorUserAgent('firefox') && fragment.append(createText())\n  for (const content of props.contents) {\n    fragment.appendChild(createContent(content))\n  }\n  // ... else ...\n}\n\nfunction handleChildListChange(mutation: MutationRecord) {\n  // 确保占位元素的存在 （兼容 FireFox）\n  if (checkNavigatorUserAgent('firefox')) {\n    insertInputPlaceholder(tagTextEditorRef.value!)\n  }\n  //  ... else ...\n}\n```\n在实现完上述的解决方案后，又会引申另一个问题，即删除所有元素后，模拟的 **placeholder** 并没有按照预期出现，这说明容器中尚且存在占位元素。**（这个问题在 Chrome 浏览器 中也存在）**\n\n![05](https://media2.giphy.com/media/v1.Y2lkPTc5MGI3NjExaWZyYzM1Y2RmdTV6YnNodjZ5MWUwM3FjZ2JvNnQzYWJ5ZXVpY2RmYSZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/QruqDFj8VhNn9gHzdH/giphy.gif)\n\n打印一下此时编辑器的子元素：\n\n![06](https://media4.giphy.com/media/v1.Y2lkPTc5MGI3NjExdWRwaXh2bGozeHh5Nm9ueTgwMXNxcWZjaThrYWV6YmNkaW91MWk5aCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/ZaMqejQuAxPVhXM4oZ/giphy.gif)\n\n可见还存在占位元素，这时就需要手动清除，让编辑器内容完全为空。\n\n```ts\n// tool.ts\n\n// 彻底清空输入框无用内容 ( 让模拟表单元素中的placeholder能够正常显示 )\nexport function clearUnableDomForTagTextEditor(container: HTMLElement) {\n  const { firstChild, lastChild } = container\n  const childCount = container.childNodes.length\n  const isClear = lastChild?.nodeName === 'BR' && (firstChild?.nodeType === Node.TEXT_NODE && firstChild.textContent === '')\n  if (isClear && childCount <= 2)\n    container.innerHTML = ''\n}\n\n// PicTagTextEditor.vue\n\nfunction handleChildListChange(mutation: MutationRecord) {\n  if (checkNavigatorUserAgent('firefox')) {\n    insertInputPlaceholder(tagTextEditorRef.value!)\n  }\n\n  // 判断可用内容是否为空，若为空，则清空容器\n  clearUnableDomForTagTextEditor(tagTextEditorRef.value!)\n  //  ... else ...\n}\n```\n\n至此一个基础的 **文本** 和 **tag (非文本)** 混合输入框就实现了。\n\n#### 可扩展性还是很强的，比如\n\n- **tag** 的外形和内部的元素组成，可以在 **creatTag** 中自行修改；\n- 编辑器的的后缀内容（可通过插槽进行预设，可能会用到 `:focus-within 伪类`）\n- **tag** 数据内容的负载，负载一些在删除时需要的核心字段等等（可将 `data-*` 作为数据携带的载体）\n- 结合当下UI组件库的组件，进一步封装为 **下拉框** 等等。\n\n<font color=red>[注意]：目前只兼容 **Chrome** 、**Microsoft Edge**、 **FireFox** 浏览器</font>\n",
    "data": {
      "Created At": "8/1/2025, 4:22:48 PM",
      "Updated At": "8/4/2025, 9:32:15 AM",
      "File Name": "PicTagTextEditor组件的封装",
      "Path": "src/notes/components/PicTagTextEditor组件的封装.md",
      "Tag": "components"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "devploy-project": {
    "content": "\n# 项目部署\n\n## 准备工作：\n\n- 云服务器\n- GitHub 项目地址\n- 操作系统（macOS 或 Linux）\n\n## 使用 SSH 连接到服务器\n\n（一）在本地电脑终端输入连接指令\n\n```bash\nssh root@服务器公网IP\n\n# 例如\nssh root@39.105.23.101\n```\n\n连接显示：\n\n```vbnet\nThe authenticity of host 'xxxxx (39.105.23.101)' can't be established.\nECDSA key fingerprint is SHA256:xxxxxxxxxxxx.\nAre you sure you want to continue connecting (yes/no)?\n```\n输入 `yes ` 回车确认。\n\n若提示以下内容说明\n\n```bash\nroot@39.105.23.101: Permission denied (publickey).\n```\n\n- 没有在本地配置对应的 SSH 私钥\n- 服务器上没有把本地创建的公钥添加到 `root` 用户的 `~/.ssh/authorized_keys` 文件里\n\n### 解决方法：\n\n（1）本地生成 SSH 密钥对（若没有），在终端输入：\n\n```bash\nssh-keygen -t ed25519 -C \"your_email@example.com\"\n\n# ssh-keygen：这是用来生成 SSH 密钥对的命令。\n# -t ed25519：指定密钥类型为 ed25519，这是一种现代、安全且速度快的公钥算法，推荐使用。\n# -C \"your_email@example.com\"：这是给密钥加一个注释（comment），可写可不写，实际上这个字符串对密钥功能没有影响。\n```\n\n（2）一路回车，默认生成：\n\n- 公钥： `~/.ssh/id_ed25519.pub`\n- 私钥： `~/.ssh/id_ed25519`\n\n若显示以下内容：\n\n```bash\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/Users/xxx（用户名）/.ssh/id_ed25519):\n```\n意思是让你确认把刚生成的密钥保存在哪个文件路径。默认是：\n\n```bash\n/Users/xxxx(用户名)/.ssh/id_ed25519\n```\n\n后续直接回车即可（其中步骤还有询问是否设置密码，回车则默认不设置）\n\n若出现以下提示：\n\n```bash\nEnter passphrase (empty for no passphrase):\n```\n\n表示让你为这个密钥设置一个 `口令（密码）`，是对该密钥的额外保护。\n\n这里 `输入一个口令` 或 `直接回车`，(不设置口令。以后用这个私钥登录时，不需要额外输入密码，方便但安全性略低.)\n\n（3）拷贝公钥\n\n```bash\ncat ~/.ssh/id_ed25519.pub\n```\n\n（4）在已登陆的账号中进入云服务器的后台\n\n- 进入 `网络安全/密钥对` 菜单\n- 点击 `创建密钥对`\n- 点击 `导入已有密钥对`类型选项\n- 粘贴上述复制的 `公钥内容`\n\n(5) 密钥绑定完成后，准备再次登录到云服务器，在本地终端中输入\n\n```bash\nssh -i ~/.ssh/id_ed25519 root@39.105.23.101\n```\n\n* `ssh`：表示使用 SSH 客户端发起远程连接。\n* `-i`: 表示指定登录时要用的私钥文件路径\n* `~/.ssh/id_ed25519`: 是你本地生成的 私钥（和服务器上绑定的公钥是一对的）\n* `root`: 是你要登录的远程用户名（这里是云服务器的超级管理员账号）\n* `39.105.23.101` 是你云服务器的公网 IP 地址\n\n用这个私钥来验证你就是密钥拥有者，不用密码登录\n\n登陆成功进入服务器后，终端的头部会显示为：\n\n```bash\nroot@iZbp1a27xd83ndots9hqq9Z:~#\n\n# 输入 exit 即可退出\n```\n\n这样就算是使用 SSH 连接云服务器成功。\n\n(6) 为登陆的便捷性，编辑本地 `~/.ssh/config` ，\n\n`nano` 是终端中简单的文本编辑器\n\n```bash\nnano ~/.ssh/config\n```\n\n粘贴以下内容，按下 `Ctrl + O`(提示文件名时，按回车确认)，回车确认保存，然后按 `Ctrl + X` 退出。\n\n* `Host aliyun-server` ：这是给这条连接起的别名，以后只要输入 `ssh aliyun-server` 就能登录。\n* `HostName` ：你的服务器公网 IP 或域名。\n* `User` ：登录用户名（你一般用 root）。\n* `IdentityFile` ：你本地私钥的路径。\n\n```text\nHost aliyun-server\n  HostName 39.105.23.101\n  User root\n  IdentityFile ~/.ssh/id_ed25519\n```\n\n以后登陆到服务器只需要输入：\n\n```bash\nssh aliyun-server\n```\n\n## 开始部署\n\n（1）连接到云服务器后，终端中输入以下指令，更新云服务器系统和安装必要软件\n\n```bash\nsudo apt update && sudo apt upgrade -y\nsudo apt install -y git\n```\n\n若出现以下内容：直接选择 `OK`（提示有服务（这里是 packagekit.service）使用了过时的库，需要重启以应用更新。）\n\n```\n       Daemons using outdated libraries\n│                                             │\n│                                             │\n│ Which services should be restarted?         │\n│                                             │\n│    [*] packagekit.service                   │\n│                                             │\n│                                             │\n│          <Ok>              <Cancel>         |\n\n```\n\n（2）安装运行环境（我的项目是 vue 项目， 所以需要 Node.js）\n\n```bash\ncurl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -\n\nsudo apt install -y nodejs\n```\n\n- curl 是一个命令行工具，用来从网上下载内容。\n- `-f`：失败时不输出错误页面（fail silently）。\n- `-s`：静默模式，不显示下载过程。\n- `-S`：配合 -s，失败时显示错误信息。\n- `-L`：遇到重定向时跟随跳转。\n- 网址 https://deb.nodesource.com/setup_20.x 是 NodeSource 提供的一个脚本，用来帮你在 Ubuntu/Debian 系统中配- 置 Node.js 20.x 的官方软件源。\n- 管道符` | `把下载下来的脚本直接传给后面执行。\n- `sudo -E bash -`：用 root 权限（sudo）执行这个脚本，-E 表示保留当前用户的环境变量，bash - 表示从标准输入读取脚本内容并执行\n\n（可选）使用 npm 全局安装 pnpm（最新的 10.x 版本）：\n\n```bash\nsudo npm install -g pnpm@10\n```\n\n（3）克隆 GitHub 项目\n\n安装 `git` (若没有)\n\n```bash\nsudo apt install git -y\n```\n\n拉取项目\n```bash\ncd /opt  # 或其他你想放项目的目录\n\ngit clone https://github.com/你的用户名/你的仓库.git\n\ncd 你的仓库\n```\n(4) 安装依赖，启动项目\n\n```bash\npnpm install\npnpm build\n```\n\n(5) 安装并配置 Nginx 作为静态文件服务器\n\n```bash\nsudo apt install nginx -y\n```\n\n创建配置文件，配置 nginx\n\n```bash\nsudo nano /etc/nginx/sites-available/picture\n```\n\n写入下面配置（假设你想用服务器的 80 端口访问）：\n\n```nginx\nserver {\n    listen 80;\n    server_name 39.105.23.101;\n\n    root /opt/Picture/dist;\n    index index.html;\n\n    # 处理以 /Picture/ 开头的请求，映射到 dist 目录\n    location /Picture/ {\n        alias /opt/Picture/dist/;\n        try_files $uri $uri/ /Picture/index.html;\n    }\n\n    # 根路径重定向到 /Picture/\n    location = / {\n        return 301 /Picture/;\n    }\n}\n\n```\n\n启用该配置并重启 Nginx\n\n```bash\nsudo ln -s /etc/nginx/sites-available/picture /etc/nginx/sites-enabled/\n\nsudo nginx -t\n\nsudo systemctl restart nginx\n```\n测试访问\n\n```bash\nhttp://服务器IP(公网IP)\n```\n\n(6) 在阿里云控制台检查和开放安全组 80 端口\n\n* 进入 `网络与安全/安全组`\n* 点击 `创建安全组`\n* 在规则配置选项下，点击 `增加规则`\n\n![增加规则](devploy-01.png)\n\n## 更新服务器项目\n\n登陆云服务，使用指令寻到项目根目录地址\n\n```bash\n# 进入项目目录\ncd /opt/picture\n\ngit pull origin main\n\npnpm install\n\npnpm  build\n\nsudo nginx -t\n\nsudo systemctl restart nginx\n```\n\n## 问题处理\n\n若在拉取代码的时候出现以下错误：\n\n```bash\nfatal: unable to access 'https://github.com/xxxxx/仓库名.git/': Failed to connect to github.com port 443 after 130178 ms: Connection timed out\n\nerror: RPC failed; curl 16 Error in the HTTP2 framing layer\nfatal: expected flush after ref listing\n```\n\n解决方法：\n\n- 增加 Git HTTP 缓冲区大小（设置为 500MB，避免大文件传输时缓冲区过小）\n\n```bash\ngit config --global http.postBuffer 524288000\n```\n\n- 强制 Git 使用 HTTP/1.1 而非 HTTP/2\n\n```bash\ngit config --global http.version HTTP/1.1\n```\n\n- 取消 Git 的 http/https 的代理\n\n```bash\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n# 查看 Git 配置代理\ngit config --global --get http.proxy\ngit config --global --get https.proxy\n\n# 设置代理\ngit config --global http.proxy http://127.0.0.1:9097\ngit config --global https.proxy http://127.0.0.1:9097\n```\n",
    "data": {
      "Created At": "8/11/2025, 9:52:40 AM",
      "Updated At": "8/11/2025, 3:46:52 PM",
      "File Name": "devploy-project",
      "Path": "src/notes/devops/devploy-project.md",
      "Tag": "devops"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "vim常用指令": {
    "content": "\n### 🛠️ 使用 Vim 的基本命令\n\n- 进入插入模式：按 `i` 键开始编辑文本。\n- 保存并退出：按 `Esc` 键，然后输入 :`wq`，按 `Enter` 键。\n- 仅保存：按 `Esc` 键，然后输入 :`w`，按 `Enter` 键。\n- 不保存退出：按 `Esc` 键，然后输入 :`q!`，按 `Enter` 键\n",
    "data": {
      "Created At": "8/1/2025, 4:22:51 PM",
      "Updated At": "8/4/2025, 9:31:50 AM",
      "File Name": "vim常用指令",
      "Path": "src/notes/command/vim常用指令.md",
      "Tag": "command"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "使用mac遇到的问题": {
    "content": "\n# zsh: command not found: nvm 问题（Mac）\n\n### 打开终端输入\n```bash\nbrew install nvm\n```\n### 检查是否安装成功\n```bash\nnvm --version\n```\n### 若出现 `zsh: command not found: nvm` 报错,解决方法如下\n\n(1) 打开 `.bash_profile` 文件进行修改。\n\n```bash\nvim  ~/.bash_profile\n```\n(2) 按键盘 “i”，可在当前打开的文件中插入文本内容\n\n```bash\nexport NVM_DIR=~/.nvm\nsource $(brew --prefix nvm)/nvm.sh\n```\n(3) 按键盘 shift + \":\"，输入 \"wq\" 进行保存并退出\n\n(4) 打开 `.zshrc `文件进行修改 (插入文本内容同上操作)\n\n```bash\nvim ~/.zshrc\n```\n(5) 打开 `.profile` 文件进行修改 (插入文本内容同上操作)\n\n```bash\nvim ~/.profile\n```\n(6)  依次运行下面代码，进行文件的重新加载\n\n```bash\nsource  ~/.bash_profile\nsource  ~/.zshrc\nsource  ~/.profile\n```\n\n(7) 在验证 nvm 是否安装成功\n\n```bash\nnvm --version\n```\n\n引用内容来自：\n- [zsh: command not found: nvm 问题（Mac）](https://blog.csdn.net/qq_50386946/article/details/143053977?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-143053977-blog-137523394.235%5Ev43%5Epc_blog_bottom_relevance_base2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-5-143053977-blog-137523394.235%5Ev43%5Epc_blog_bottom_relevance_base2&utm_relevant_index=9)\n",
    "data": {
      "Created At": "8/1/2025, 4:22:50 PM",
      "Updated At": "8/4/2025, 9:32:03 AM",
      "File Name": "使用mac遇到的问题",
      "Path": "src/notes/command/使用mac遇到的问题.md",
      "Tag": "command"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "ci error": {
    "content": "\n# Vite - Adding auto-imports.d.ts to gitignore, generates error building for production\n\nfrom\n```json\n{\n  \"build\": \"vue-tsc --noEmit && vite build\"\n}\n```\n\nto\n```json\n{\n  \"build\": \"vite build && vue-tsc --noEmit\"\n}\n```\n\n`vue-tsc --noEmit`\n\n- vue-tsc 是 Vue 官方提供的一个 TypeScript 类型检查工具，基于 tsc，但更适配 .vue 文件。\n- --noEmit 表示只进行类型检查，不输出任何文件（不会编译生成 js 或 d.ts）。\n- 这个命令用于在构建后严格检查代码类型是否正确。\n",
    "data": {
      "Created At": "8/1/2025, 4:22:41 PM",
      "Updated At": "8/4/2025, 9:32:26 AM",
      "File Name": "ci error",
      "Path": "src/notes/git/ci error.md",
      "Tag": "git"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "git 提交问题": {
    "content": "\n### ✅ **Git 常见问题总结**\n\n---\n\n## 1️⃣ `git pull` 提示 divergent branches\n\n本地与远程分支存在不同提交历史，Git 无法确定使用 **merge**、**rebase** 还是 **fast-forward**。\n\n### 解决办法：\n\n使用 `rebase` 保持提交历史干净：\n\n```bash\ngit pull origin main --rebase\n```\n\n可设置全局默认：\n\n```bash\ngit config --global pull.rebase true\n```\n\n---\n\n## 2️⃣ `git pull --rebase` 报错：You have unstaged changes\n\n工作区存在未提交改动，`rebase` 无法进行。\n\n### 解决办法：\n\n暂存改动后再操作：\n\n```bash\ngit stash\ngit pull origin main --rebase\ngit stash pop\n```\n\n---\n\n## 3️⃣ 正在 `rebase` 时卡住，提示 continue 或 amend\n\n在 `rebase` 过程中改动未提交，需要继续操作。\n\n### 解决办法：\n\n```bash\ngit add .\ngit commit --amend\ngit rebase --continue\n```\n\n放弃此次 `rebase`：\n\n```bash\ngit rebase --abort\n```\n\n---\n\n## 4️⃣ `git push` 提示 non-fast-forward\n\n远程分支有更新，推送被拒绝。\n\n### 解决办法：\n\n先同步远程，再推送：\n\n```bash\ngit pull origin main --rebase\ngit push origin main\n```\n\n覆盖远程（慎用）：\n\n```bash\ngit push origin main --force\n```\n\n---\n\n## 5️⃣ 成功 rebase 后的操作\n\n`rebase` 完成后需强制推送：\n\n```bash\ngit push origin main --force\n```\n\n---\n\n## 6️⃣ 撤回上一次提交的操作\n\n### 本地未 push：\n\n| 是否保留改动 | 命令                       |\n| ------ | ------------------------ |\n| 保留改动   | `git reset --soft HEAD^` |\n| 丢弃改动   | `git reset --hard HEAD^` |\n\n### 已 push：\n\n```bash\ngit reset --soft HEAD^\ngit push origin main --force\n```\n\n---\n\n## 7️⃣ 修改最后一次 commit（已 push）\n\n### 操作步骤：\n\n```bash\ngit add .\ngit commit --amend\ngit push origin main --force\n```\n\n---\n\n## 🔔 **常见命令总结**\n\n| 操作         | 命令                              |\n| ---------- | ------------------------------- |\n| 拉远程并保持历史干净 | `git pull origin main --rebase` |\n| 暂存改动       | `git stash` / `git stash pop`   |\n| 撤回提交保留改动   | `git reset --soft HEAD^`        |\n| 撤回提交丢弃改动   | `git reset --hard HEAD^`        |\n| 修改最后提交     | `git commit --amend`            |\n| 强制推送       | `git push origin main --force`  |\n| 放弃 rebase  | `git rebase --abort`            |\n| 继续 rebase  | `git rebase --continue`         |\n\n---\n\n## 🚩 **推荐 Git 配置**\n\n```bash\ngit config --global pull.rebase true       # 默认使用 rebase\ngit config --global pull.ff only           # 或仅允许 fast-forward\n```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:42 PM",
      "Updated At": "8/4/2025, 9:32:30 AM",
      "File Name": "git 提交问题",
      "Path": "src/notes/git/git 提交问题.md",
      "Tag": "git"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "git常用指令": {
    "content": "\n# git 常用指令\n\n#### 以 SSH 方式 clone 的远程仓库\n\n#### 以 HTTPS 方式 clone 的远程仓库\n\n#### 查看当前与远程仓库的关联方式\n\n```bash\ngit remote -v\n```\n\n#### 移除当前本地关联的远程仓库\n\n```bash\ngit remote remove origin\n```\n\n#### 本地代码关联远程仓库\n\n```bash\ngit remote add origin [https | ssh]\n```\n\n#### 代码回退\n\n```bash\n# 回退到指定版本\ngit reset --hard commit_id\n\n# 回退到上一个版本\ngit reset --soft HEAD^\n```\n\n#### 分支相关(查看，创建，删除)\n\n```bash\n# 查看所有远程分支\ngit branch - r\n\n# 查看本地分支\ngit branch --list\n\n# 拉取远程分支并创建本地分支\ngit checkout -b localBranchName origin/remoteBranchName # 方法1\ngit fetch origin remoteBranchName:localBranchName # 方法2\n\n# 删除本地分支\ngit branch -d localBranchName\n\n# 强制删除本地分支\ngit branch -D branch_name\n\n# 删除远程分支\ngit push origin --delete remoteBranchName\n```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:42 PM",
      "Updated At": "8/4/2025, 9:32:34 AM",
      "File Name": "git常用指令",
      "Path": "src/notes/git/git常用指令.md",
      "Tag": "git"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "Set": {
    "content": "\n### 概述：\n\n`Set` 是一种集合数据结构，它类似于数组，但成员的值都是唯一的，没有重复的值。\n\n### 特性：\n\n- 唯一性: 值不重复\n- 无序性: 没有索引值\n- 可迭代性: 可用 `for...of` 和 `forEach` 遍历\n\n### 常用方法：\n\n- `add(value)`：添加一个值，返回 Set 本身。\n- `delete(value)`：删除某个值，返回布尔值表示是否删除成功。\n- `has(value)`：判断是否存在某个值，返回布尔值。\n- `clear()`：清空所有值。\n- `size`：返回 Set 中值的数量。\n\n### 应用场景：\n\n1. 数组去重（普通数组去重）\n2. 避免重复操作（表单提交操作等）\n3. 关系型数据管理（高效查找）\n\n    ```js\n    // 社交网络好友关系\n    const userRelations = new Map()\n\n    function addFriend(userId, friendId) {\n      const friends = userRelations.get(userId) || new Set()\n      friends.add(friendId)\n      userRelations.set(userId, friends)\n    }\n\n    // 检查是否是好友：O(1)\n    function isFriend(userId, friendId) {\n      return userRelations.get(userId)?.has(friendId) ?? false\n    }\n    ```\n4. WeakSet 特殊场景 (弱引用特性避免内存泄漏)\n    ```js\n    // DOM 元素追踪\n    const trackedElements = new WeakSet()\n\n    function trackElement(element) {\n      trackedElements.add(element)\n    }\n\n    // 检查是否被追踪过\n    function isTracked(element) {\n      return trackedElements.has(element)\n    }\n\n    // 当元素被移除DOM后，WeakSet自动释放引用\n    ```\n\n---\n\n### 选择 Set 的决策树\n1. 需要快速判断元素是否存在？ → ✅\n2. 需要自动保证元素唯一性？ → ✅\n3. 需要处理集合数学运算？ → ✅\n4. 需要有序存储或索引访问？ → ❌（选择 Array）\n5. 需要存储重复元素？ → ❌（选择 Array）\n6. 需要存储原始值和对象引用？ → ✅\n\n---\n\n**性能对比**（V8 引擎基准测试）：\n| 操作     | Array | Set  |\n| -------- | ----- | ---- |\n| 查找元素 | O(n)  | O(1) |\n| 添加元素 | O(1)  | O(1) |\n| 删除元素 | O(n)  | O(1) |\n| 遍历速度 | 更快  | 稍慢 |\n\n掌握这些场景后，可以更精准地在以下场景选择 Set：\n- 高频存在性检查\n- 需要数学集合操作\n- 需要自动去重\n- 处理唯一标识管理\n- 需要弱引用管理的特殊场景（WeakSet）\n",
    "data": {
      "Created At": "8/1/2025, 4:22:47 PM",
      "Updated At": "8/4/2025, 9:32:20 AM",
      "File Name": "Set",
      "Path": "src/notes/data-structrue/Set.md",
      "Tag": "data-structrue"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "485.最大连续  1 的个数": {
    "content": "\n# 485.最大连续  1 的个数\n\n```ts\nfunction findMaxConsecutiveOnes(nums: number[]): number {\n  let tempCount = 0\n  let maxCount = 0\n  for (let i = 0; i < nums.length; i++) {\n    if (nums[i] === 1) {\n      tempCount++\n      maxCount = Math.max(maxCount, tempCount)\n    }\n    else {\n      tempCount = 0\n    }\n  }\n  return maxCount\n};\n```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:33 PM",
      "Updated At": "8/4/2025, 10:43:19 AM",
      "File Name": "485.最大连续  1 的个数",
      "Path": "src/notes/leetcode/485.最大连续  1 的个数.md",
      "Tag": "leetcode"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "async和defer": {
    "content": "\n# async和defer\n\n在 HTML 中，`<script>` 标签的 `async` 和 `defer` 属性用于控制外部 JavaScript 文件的加载和执行方式，以优化网页的性能和用户体验。以下是这两个属性的作用、特点和区别的总结表：\n\n![async&defer](async-defer.png)\n\n| 属性   | 加载方式              | 执行时机                   | 是否阻塞 HTML 解析 | 保证执行顺序     |\n|------- |--------------------- |----------------------------|--------------------|--------------|\n| 无属性  | 遇到时立即加载并执行   | 立即，阻塞 HTML 解析       | 是                 | 是               |\n| async  | 异步加载             | 加载完成后立即执行         | 否                 | 否              |\n| defer  | 异步加载             | HTML 解析完成后按顺序执行  | 否                 | 是              |\n\n### 📌 使用建议\n\n- **`async`**：适用于不依赖其他脚本或 DOM 的独立脚本，如统计分析或广告脚本。\n\n- **`defer`**：适用于需要在 DOM 完全构建后执行的脚本，或多个有依赖关系的脚本。\n\n- **无属性**：适用于需要立即执行的内联脚本，但可能会阻塞 HTML 解析，影响页面加载性能。\n\n[注意]：<font color=red>async 和 defer 都仅适用于外部脚本；如果 `<script>` 标签没有 `src` 特性（attribute），那么 `async` 或 `defer` 的特性会被忽略。</font>\n",
    "data": {
      "Created At": "8/1/2025, 4:22:35 PM",
      "Updated At": "8/4/2025, 9:33:10 AM",
      "File Name": "async和defer",
      "Path": "src/notes/interview/async和defer.md",
      "Tag": "interview"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "this 绑定规则": {
    "content": "\n# this 四大绑定规则（和优先级）\n\n### 1. 默认绑定（最低优先级）\n\n规则：<font color=yellow>函数独立调用时，this 指向全局对象</font>\n\n环境差异：\n\n```js\n// 浏览器\nfunction test1() {\n  console.log(this === window) // true\n}\n\n// Node.js\nfunction test2() {\n  console.log(this === globalThis) // true\n}\n\n// 严格模式：\n'use strict'\nfunction strictShow() {\n  console.log(this) // undefined\n}\n```\n\n### 2. 隐式绑定（方法调用）\n\n规则：<font color=yellow>函数作为方法调用时，this 指向调用对象</font>\n\n```js\nconst car = {\n  brand: 'Tesla',\n  start() {\n    console.log(`${this.brand} starting...`)\n  }\n}\n\ncar.start() // \"Tesla starting...\" (this = car)\n```\n\n易错点：方法赋值给变量时绑定丢失\n\n```js\nconst startFn = car.start\n\nstartFn() // \"undefined starting...\" (this = window/global)\n```\n\n### 3. 显式绑定（强制绑定）\n\n方法：call()、apply()、bind()\n\n区别：\n```js\nfunction introduce(lang) {\n  console.log(`${this.name} codes in ${lang}`)\n}\n\nconst dev = { name: 'Alice' }\n\n// 立即执行\nintroduce.call(dev, 'JavaScript') // Alice codes in JavaScript\nintroduce.apply(dev, ['Python']) // Alice codes in Python\n\n// 创建新函数（延迟执行）\nconst boundFn = introduce.bind(dev)\nboundFn('Java') // Alice codes in Java\n```\n\n### 4. new 绑定（构造函数）\n\n规则：<font color=yellow>使用 new 调用时，this 指向新创建的对象</font>\n\n底层原理：\n```js\nfunction Person(name) {\n  // new 操作符自动完成：\n  // 1. this = {}\n  // 2. 执行构造函数逻辑\n  this.name = name\n  // 3. return this (隐式)\n}\n\nconst p = new Person('Bob')\nconsole.log(p.name) // \"Bob\"\n```\n\n## 两种特殊规则\n\n### 箭头函数（Lexical this）\n\n规则：继承外层作用域的 this（定义时绑定）\n\n对比普通函数：\n```js\nconst obj = {\n  value: 42,\n  normal() {\n    setTimeout(function () {\n      console.log(this.value) // undefined (默认绑定)\n    }, 100)\n  },\n  arrow() {\n    setTimeout(() => {\n      console.log(this.value) // 42 (继承 arrow 的 this)\n    }, 100)\n  }\n}\n\nobj.normal()\nobj.arrow()\n```\n\n### DOM 事件处理\n\n规则：事件处理函数中 this 指向触发事件的元素\n\n```html\n<button onclick=\"console.log(this)\">Click</button>\n<!-- 输出 <button> 元素 -->\n```\n\n# 优先级总结（从高到低）\n- new 绑定：new Foo()\n- 显式绑定：foo.call(obj)\n- 隐式绑定：obj.foo()\n- 默认绑定：foo()\n",
    "data": {
      "Created At": "8/1/2025, 4:22:36 PM",
      "Updated At": "8/4/2025, 9:33:17 AM",
      "File Name": "this 绑定规则",
      "Path": "src/notes/interview/this 绑定规则.md",
      "Tag": "interview"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "判断数据类型": {
    "content": "\n### 正则写法\n```ts\nfunction getType(value: unknown): string {\n  const match = Object.prototype.toString.call(value).match(/\\[object (\\w+)\\]/)\n  return match ? match[1].toLowerCase() : 'unknown'\n}\n```\n### 一般写法：\n\n```ts\nfunction getType(value: unknown): string {\n  const match = Object.prototype.toString.call(value).match(/\\[object (\\w+)\\]/)\n  return match ? match[1].toLowerCase() : 'unknown'\n}\n```\n\n### 统一方法：\n\n```ts\nfunction getType(obj: unknown) {\n  const type = typeof obj\n  if (type !== 'object') {\n    return type\n  }\n  return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, '$1')\n}\n```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:37 PM",
      "Updated At": "8/4/2025, 9:32:42 AM",
      "File Name": "判断数据类型",
      "Path": "src/notes/interview/判断数据类型.md",
      "Tag": "interview"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "pinia持久化插件使用": {
    "content": "\n# pinia持久化插件使用\n\n1. 安装 `piniaPluginPersistedstate`\n\n   ```cmd\n   pnpm install pinia-plugin-persistedstate\n   ```\n\n2. 在`main.ts` 引入 `piniaPluginPersistedstate`\n\n   ```ts\n   import { createPinia } from 'pinia'\n   // pinia 持久化插件引入\n   import piniaPluginPersistedstate from 'pinia-plugin-persistedstate'\n   const pinia = createPinia()\n   pinia.use(piniaPluginPersistedstate)\n\n   app.use(pinia)\n   app.mount('#app')\n   ```\n\n3. 在 `store` 中使用`persist` 为配置项\n\n   ```ts\n   import { defineStore } from 'pinia'\n   import { ref } from 'vue'\n\n   // options store\n   // export default defineStore(\"side\", {\n   //   state: () => ({ fold: true }),\n   //   getters: {},\n   //   actions: {\n   //     setSideFoldState(state: boolean) {\n   //       this.fold = state;\n   //     },\n   //   },\n   // persist: {\n   // ...配置\n   // },\n   // });\n\n   // setup store\n   export default defineStore(\n     'aside',\n     () => {\n       const fold = ref(false)\n\n       function setSideFoldState(state: boolean) {\n         fold.value = state\n       }\n\n       return { fold, setSideFoldState }\n     },\n     // 持久化配置\n     {\n       persist: {\n         key: 'aside', // 指定需要持久化变量\n         storage: sessionStorage // 指定存储位置\n       }\n     }\n   )\n   ```\n\n4. [具体细节见官方文档](https://prazdevs.github.io/pinia-plugin-persistedstate/zh/guide/)\n",
    "data": {
      "Created At": "8/4/2025, 9:33:32 AM",
      "Updated At": "8/4/2025, 9:33:39 AM",
      "File Name": "pinia持久化插件使用",
      "Path": "src/notes/pinia/pinia持久化插件使用.md",
      "Tag": "pinia"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "link": {
    "content": "\n## 🛠️ 构建工具 / 打包器 / 包管理\n\n| 名称            | 文档链接                                                 | 描述                        |\n| ------------- | ---------------------------------------------------- | ------------------------- |\n| **Vite**      | [https://vitejs.dev](https://vitejs.dev)             | 极速启动、原生 ESM 支持，现代开发首选     |\n| **Webpack**   | [https://webpack.js.org](https://webpack.js.org)     | 功能齐全，适合大型项目，插件生态丰富        |\n| **Rollup**    | [https://rollupjs.org](https://rollupjs.org)         | 适用于库打包，tree-shaking 友好    |\n| **Turbopack** | [https://turbo.build/pack](https://turbo.build/pack) | Vercel 推出的 Webpack 替代品    |\n| **PNPM**      | [https://pnpm.io](https://pnpm.io)                   | 快速节省空间的包管理器               |\n| **Yarn**      | [https://yarnpkg.com](https://yarnpkg.com)           | Facebook 推出，改进 npm 性能和稳定性 |\n| **Turborepo** | [https://turbo.build/repo](https://turbo.build/repo) | 高性能 Monorepo 构建工具         |\n| **Lerna**     | [https://lerna.js.org](https://lerna.js.org)         | 多包管理工具，常配合 Monorepo 使用    |\n\n---\n\n## 🧩 UI 组件库 / CSS 工具类\n\n| 名称               | 文档链接                                                 | 描述                          |\n| ---------------- | ---------------------------------------------------- | --------------------------- |\n| **Tailwind CSS** | [https://tailwindcss.com](https://tailwindcss.com)   | 原子化 CSS 工具类框架，灵活快速          |\n| **UnoCSS**       | [https://unocss.dev](https://unocss.dev)             | 体积小、按需生成的原子化 CSS 引擎         |\n| **Ant Design**   | [https://ant.design](https://ant.design)             | 蚂蚁集团推出的 React 企业级组件库        |\n| **Element Plus** | [https://element-plus.org](https://element-plus.org) | Vue 3 的成熟 UI 库，适合后台系统       |\n| **Mantine**      | [https://mantine.dev](https://mantine.dev)           | React 的现代化 UI 库，内置 hooks 支持 |\n\n---\n\n## 🔁 状态管理\n\n| 名称                | 文档链接                                                         | 描述                           |\n| ----------------- | ------------------------------------------------------------ | ---------------------------- |\n| **Pinia**         | [https://pinia.vuejs.org](https://pinia.vuejs.org)           | Vue 3 官方推荐状态管理库              |\n| **Zustand**       | [https://zustand-demo.pmnd.rs](https://zustand-demo.pmnd.rs) | 小巧高效的 React 状态管理工具           |\n| **Redux Toolkit** | [https://redux-toolkit.js.org](https://redux-toolkit.js.org) | Redux 官方推荐简化版                |\n| **Recoil**        | [https://recoiljs.org](https://recoiljs.org)                 | Facebook 推出的 React 状态库，原子化理念 |\n\n---\n\n## 📡 数据请求 & 缓存管理\n\n| 名称                 | 文档链接                                                     | 描述                                         |\n| ------------------ | -------------------------------------------------------- | ------------------------------------------ |\n| **Axios**          | [https://axios-http.com](https://axios-http.com)         | 流行的基于 Promise 的 HTTP 客户端                   |\n| **TanStack Query** | [https://tanstack.com/query](https://tanstack.com/query) | React/Vue/Solid 的服务端数据状态管理库（原 React Query） |\n| **SWR**            | [https://swr.vercel.app](https://swr.vercel.app)         | Next.js 团队推出的数据获取库，支持缓存和重验证                |\n\n---\n\n## 🔍 路由\n\n| 名称                  | 文档链接                                                       | 描述                 |\n| ------------------- | ---------------------------------------------------------- | ------------------ |\n| **Vue Router**      | [https://router.vuejs.org](https://router.vuejs.org)       | Vue 官方路由解决方案       |\n| **React Router**    | [https://reactrouter.com](https://reactrouter.com)         | React 应用的标准路由库     |\n| **TanStack Router** | [https://tanstack.com/router](https://tanstack.com/router) | 新一代类型安全、声明式的路由解决方案 |\n\n---\n\n## ✨ 编辑器 / 可视化引擎\n\n| 名称                | 文档链接                                                                                   | 描述                        |\n| ----------------- | -------------------------------------------------------------------------------------- | ------------------------- |\n| **Monaco Editor** | [https://microsoft.github.io/monaco-editor](https://microsoft.github.io/monaco-editor) | VS Code 的底层编辑器，适合构建在线 IDE |\n| **CodeMirror 6**  | [https://codemirror.net/6/](https://codemirror.net/6/)                                 | 可配置、高性能的代码编辑器             |\n| **Three.js**      | [https://threejs.org](https://threejs.org)                                             | WebGL 封装库，创建 3D 可视化场景     |\n| **PixiJS**        | [https://pixijs.com](https://pixijs.com)                                               | 高性能 2D 渲染引擎，适合游戏与图形应用     |\n| **Fabric.js**     | [http://fabricjs.com/](http://fabricjs.com/)                                           | HTML5 Canvas 上的交互式图形库     |\n\n---\n\n## 📊 可视化 / 图表库\n\n| 名称           | 文档链接                                                     | 描述                    |\n| ------------ | -------------------------------------------------------- | --------------------- |\n| **ECharts**  | [https://echarts.apache.org](https://echarts.apache.org) | 百度团队开发的强大图表库，适合大数据可视化 |\n| **Chart.js** | [https://www.chartjs.org](https://www.chartjs.org)       | 简单易用的图表绘制库，适合轻量需求     |\n| **D3.js**    | [https://d3js.org](https://d3js.org)                     | 数据驱动文档，适用于复杂交互可视化     |\n\n---\n\n## 🧪 测试工具\n\n| 名称                  | 文档链接                                                       | 描述                           |\n| ------------------- | ---------------------------------------------------------- | ---------------------------- |\n| **Vitest**          | [https://vitest.dev](https://vitest.dev)                   | Vite 原生测试框架，支持快照、mock        |\n| **Jest**            | [https://jestjs.io](https://jestjs.io)                     | Facebook 推出的 JavaScript 测试框架 |\n| **Cypress**         | [https://www.cypress.io](https://www.cypress.io)           | E2E 测试工具，浏览器自动化强大            |\n| **Playwright**      | [https://playwright.dev](https://playwright.dev)           | 支持多浏览器的 E2E 测试库              |\n| **Testing Library** | [https://testing-library.com](https://testing-library.com) | 基于用户行为的测试工具，适配 React/Vue 等框架 |\n\n---\n\n## 📖 文档 & 组件开发\n\n| 名称                   | 文档链接                                                                       | 描述                         |\n| -------------------- | -------------------------------------------------------------------------- | -------------------------- |\n| **Storybook**        | [https://storybook.js.org](https://storybook.js.org)                       | 独立开发与文档化 UI 组件的工具          |\n| **Vue Styleguidist** | [https://vue-styleguidist.github.io/](https://vue-styleguidist.github.io/) | Vue 组件文档生成工具               |\n| **Docz**             | [https://www.docz.site/](https://www.docz.site/)                           | 基于 MDX 的组件文档生成工具（React 生态） |\n\n---\n\n## 🧹 代码质量 / Lint / 格式化\n\n| 名称            | 文档链接                                         | 描述                           |\n| ------------- | -------------------------------------------- | ---------------------------- |\n| **ESLint**    | [https://eslint.org](https://eslint.org)     | JavaScript/TypeScript 静态分析工具 |\n| **Prettier**  | [https://prettier.io](https://prettier.io)   | 代码格式化工具，团队协作标配               |\n| **Stylelint** | [https://stylelint.io](https://stylelint.io) | 样式（CSS/SCSS）代码检查工具           |\n\n---\n\n## 📱 跨端开发（移动 / 桌面）\n\n| 名称               | 文档链接                                                     | 描述                          |\n| ---------------- | -------------------------------------------------------- | --------------------------- |\n| **React Native** | [https://reactnative.dev](https://reactnative.dev)       | React 构建原生 App 的跨平台方案       |\n| **Expo**         | [https://expo.dev](https://expo.dev)                     | React Native 的工具平台，支持快速打包发布 |\n| **Electron**     | [https://www.electronjs.org](https://www.electronjs.org) | 使用 Web 技术构建桌面应用（跨平台）        |\n| **Tauri**        | [https://tauri.app](https://tauri.app)                   | 体积更小、安全性更高的桌面应用开发方案         |\n\n---\n\n## 🧠 动画 / 动效引擎\n\n| 名称                | 文档链接                                                             | 描述                             |\n| ----------------- | ---------------------------------------------------------------- | ------------------------------ |\n| **Framer Motion** | [https://www.framer.com/motion/](https://www.framer.com/motion/) | React 的动画库，声明式写法，交互流畅          |\n| **GSAP**          | [https://gsap.com](https://gsap.com)                             | GreenSock 动画平台，功能强大的 JS 动画库    |\n| **Anime.js**      | [https://animejs.com](https://animejs.com)                       | 轻量但功能全面的动画库，适合 SVG/DOM/JS 对象动画 |\n| **Lottie Web**    | [https://airbnb.io/lottie/#/](https://airbnb.io/lottie/#/)       | 支持导出 AE 动画为 JSON 在 Web 中渲染     |\n\n---\n\n## 🧮 表单处理 / 校验库\n\n| 名称                  | 文档链接                                                                   | 描述                        |\n| ------------------- | ---------------------------------------------------------------------- | ------------------------- |\n| **React Hook Form** | [https://react-hook-form.com](https://react-hook-form.com)             | 高性能、无控表单解决方案              |\n| **Formik**          | [https://formik.org](https://formik.org)                               | React 中流行的表单状态管理库         |\n| **VeeValidate**     | [https://vee-validate.logaretm.com](https://vee-validate.logaretm.com) | Vue 表单验证库，组合式 API 友好      |\n| **Zod**             | [https://zod.dev](https://zod.dev)                                     | 类型安全的模式验证器，常用于前端/后端校验     |\n| **Yup**             | [https://github.com/jquense/yup](https://github.com/jquense/yup)       | 对象 schema 验证器，Formik 默认支持 |\n\n---\n\n## ⚙️ 工程化 / 自动化工具\n\n| 名称              | 文档链接                                                                                 | 描述                                  |\n| --------------- | ------------------------------------------------------------------------------------ | ----------------------------------- |\n| **Husky**       | [https://typicode.github.io/husky](https://typicode.github.io/husky)                 | Git hooks 工具，常用于提交前校验               |\n| **Commitlint**  | [https://commitlint.js.org](https://commitlint.js.org)                               | 校验 Git 提交规范（如 Conventional Commits） |\n| **Lint-staged** | [https://github.com/okonet/lint-staged](https://github.com/okonet/lint-staged)       | 只对 Git 暂存文件执行 lint/格式化等命令           |\n| **Changesets**  | [https://github.com/changesets/changesets](https://github.com/changesets/changesets) | 自动生成 changelog 和版本号，用于包管理发布         |\n\n---\n\n## 📄 静态站点生成器 / 文档站\n\n| 名称             | 文档链接                                                     | 描述                           |\n| -------------- | -------------------------------------------------------- | ---------------------------- |\n| **VitePress**  | [https://vitepress.dev](https://vitepress.dev)           | Vite + Vue 驱动的文档生成器          |\n| **VuePress**   | [https://vuepress.vuejs.org](https://vuepress.vuejs.org) | Vue 驱动的静态文档站点工具              |\n| **Docusaurus** | [https://docusaurus.io](https://docusaurus.io)           | Facebook 推出的 React 驱动静态网站生成器 |\n| **Astro**      | [https://astro.build](https://astro.build)               | 支持多框架组件，零 JS 默认输出的静态站构建工具    |\n\n---\n\n## 🔗 GraphQL 相关工具\n\n| 名称                  | 文档链接                                                                                   | 描述                         |\n| ------------------- | -------------------------------------------------------------------------------------- | -------------------------- |\n| **Apollo Client**   | [https://www.apollographql.com/docs/react](https://www.apollographql.com/docs/react)   | 主流 GraphQL 客户端，支持缓存、订阅等    |\n| **urql**            | [https://formidable.com/open-source/urql/](https://formidable.com/open-source/urql/)   | 小巧灵活的 GraphQL 客户端          |\n| **GraphQL Codegen** | [https://www.graphql-code-generator.com](https://www.graphql-code-generator.com)       | 自动从 schema 生成类型和 hooks 的工具 |\n| **GraphQL Yoga**    | [https://the-guild.dev/graphql/yoga-server](https://the-guild.dev/graphql/yoga-server) | 可用于全栈项目的 GraphQL 服务端引擎     |\n\n---\n\n## 🧭 可观测性 / 性能分析\n\n| 名称             | 文档链接                                                                                                     | 描述                      |\n| -------------- | -------------------------------------------------------------------------------------------------------- | ----------------------- |\n| **Sentry**     | [https://sentry.io](https://sentry.io)                                                                   | 前端/后端异常监控平台             |\n| **LogRocket**  | [https://logrocket.com](https://logrocket.com)                                                           | 可回放用户操作的视频日志系统          |\n| **Lighthouse** | [https://developers.google.com/web/tools/lighthouse](https://developers.google.com/web/tools/lighthouse) | Google 官方性能分析工具         |\n| **Web Vitals** | [https://web.dev/vitals/](https://web.dev/vitals/)                                                       | 用于衡量核心页面体验指标（如 LCP、FID） |\n\n---\n\n## 📦 包 / 运行时优化工具\n\n| 名称               | 文档链接                                                                         | 描述                      |\n| ---------------- | ---------------------------------------------------------------------------- | ----------------------- |\n| **esbuild**      | [https://esbuild.github.io](https://esbuild.github.io)                       | 超高速构建工具，Vite 早期依赖       |\n| **SWC**          | [https://swc.rs](https://swc.rs)                                             | Rust 编写的 JS/TS 编译器，性能优异 |\n| **unplugin**     | [https://github.com/unplugin/unplugin](https://github.com/unplugin/unplugin) | 通用 Vite/Webpack 插件开发工具集 |\n| **Bundlephobia** | [https://bundlephobia.com](https://bundlephobia.com)                         | 在线查看 npm 包体积及依赖分析       |\n\n---\n\n## 🧰 其他实用工具库\n\n| 名称               | 文档链接                                                                               | 描述                             |\n| ---------------- | ---------------------------------------------------------------------------------- | ------------------------------ |\n| **Lodash**       | [https://lodash.com](https://lodash.com)                                           | 工具函数集合库，如 cloneDeep、debounce 等 |\n| **Day.js**       | [https://day.js.org](https://day.js.org)                                           | 轻量日期处理库，API 类似 moment.js       |\n| **date-fns**     | [https://date-fns.org](https://date-fns.org)                                       | 函数式日期处理库，按需引入更轻量               |\n| **clsx**         | [https://github.com/lukeed/clsx](https://github.com/lukeed/clsx)                   | 条件 className 拼接工具              |\n| **uuid**         | [https://github.com/uuidjs/uuid](https://github.com/uuidjs/uuid)                   | 生成唯一标识符（UUID）                  |\n| **QRCode.js**    | [https://github.com/davidshimjs/qrcodejs](https://github.com/davidshimjs/qrcodejs) | 生成二维码                          |\n| **html2canvas**  | [https://html2canvas.hertzen.com](https://html2canvas.hertzen.com)                 | 将 DOM 转为 Canvas 图像             |\n| **dom-to-image** | [https://github.com/tsayen/dom-to-image](https://github.com/tsayen/dom-to-image)   | DOM 转图片，支持下载和导出为 base64        |\n\n---\n",
    "data": {
      "Created At": "8/1/2025, 4:22:31 PM",
      "Updated At": "8/4/2025, 9:33:48 AM",
      "File Name": "link",
      "Path": "src/notes/quickLinked/link.md",
      "Tag": "quickLinked"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "dependabot alerts 问题": {
    "content": "\n# Dependabot alerts（即远程仓库关于，依赖包的版本风险监测）\n\n## 风险查找\n\n#### 查看依赖树\n\n  ```bash\n  pnpm why xxx // xxx 依赖包名\n\n  或\n\n  pnpm list xxx // xxx 依赖包名\n  ```\n\n#### 清理锁文件和 node_modules，重新安装\n\n  ```bash\n  rm -rf node_modules pnpm-lock.yaml\n\n  pnpm install\n  ```\n\n####  向 npm 安全数据库查询你项目中使用的依赖是否存在安全漏洞。它分析你的 `pnpm-lock.yaml` 中锁定的包及其版本。（其中的 pnpm 的版本要和本地的 `pnpm-lock.yaml` 中的版本保持一致）\n\n  ```bash\n  pnpm audit --audit-level=moderate\n  ```\n\n ` --audit-level=moderate` : 过滤等级\n\n🔐 安全等级说明\n\n| 等级       | 描述                             |\n| ---------- | ------------------------------ |\n| `low`      | 轻微漏洞，通常不易被利用，影响有限              |\n| `moderate` | 有一定风险，可能影响数据完整性或功能             |\n| `high`     | 漏洞容易被利用，可能造成服务中断或数据泄漏          |\n| `critical` | 严重漏洞，易被攻击者远程利用，可能控制系统、导致重大安全事故 |\n\n✅ 常见用途\n\n- 在 CI/CD 中确保构建不会上线存在 中等及以上漏洞 的代码\n- 在开发中有选择性地处理问题，避免被低危漏洞干扰\n\n## 风险处理\n\n1. 一般情况下会让其升级到某个版本即可\n\n2. 存在内部依赖的包，即在 `package.json` 中的依赖项中不存在的，可通过以下配置覆盖指定依赖包的版本。\n\n    ```bash\n    dependencies:\n      axios 1.8.2\n        └── form-data 4.0.3\n    ```\n\n   ```json\n   // package.json\n   {\n     \"dependencies\": {\n       // ...\n       \"axios\": \"^1.8.2\"\n     },\n     \"devDependencies\": {\n       // ...\n     },\n     \"pnpm\": {\n       \"overrides\": {\n         \"axios>form-data\": \"4.0.4\"\n       }\n     }\n   }\n   ```\n\n    > 这个是 pnpm 独有的嵌套 overrides 语法：只对 axios 内部的 form-data 生效。\n\n    `npm 8.x`\n\n    只支持全局统一覆盖，不能指定 axios 单独用什么版本\n      ```json\n     {\n        \"overrides\": {\n          \"form-data\": \"4.0.4\"\n        }\n     }\n      ```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:22 PM",
      "Updated At": "8/4/2025, 9:34:04 AM",
      "File Name": "dependabot alerts 问题",
      "Path": "src/notes/summary/dependabot alerts 问题.md",
      "Tag": "summary"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "iPaaS": {
    "content": "\n# iPaaS\n\n### 项目描述\n> **iPaaS(Integration Platform as a Service，集成平台即服务)** 是一种云原生的微服务架构系统间集成解决方案，旨在帮助企业简化和自动化不同应用程序、数据源和服务之间的集成过程。\n>\n\n 通过提供预构建的连接器、低代码/无代码工具、数据映射和流程编排功能，**iPaaS** 使企业能够轻松地在本地系统、云服务和第三方平台之间实现数据和流程的无缝连接。\n\n#### 🧩 iPaaS 的核心功能\n\n- 应用集成: 连接各种 `SaaS 应用`、`本地系统`和`数据库`，实现数据同步和业务流程自动化。\n- 数据转换与映射: 支持不同数据格式之间的转换，确保系统间的数据兼容性。\n- API 管理: 提供 API 的`创建`、`发布`、`监控`和`安全控制`，促进服务的重用和开放。\n- 工作流自动化: 通过`可视化界面`设计和`管理跨系统`的`业务流程`，提高效率。\n- 实时监控与预警: `实时跟踪`集成流程的`运行状态`，及时发现并处理异常情况\n\n#### 🚀 iPaaS 的优势\n\n- 快速部署：无需构建复杂的中间件或编写大量代码，快速实现系统集成。\n- 灵活扩展：根据业务需求，灵活添加或修改集成流程，支持企业的快速发展。\n- 降低成本：减少手动集成的工作量和错误率，降低维护成本。\n- 提升安全性：通过统一的安全策略和访问控制，保障数据的安全传输和存储。\n\n#### 🏢 典型应用场景\n\n- 企业系统整合:  将ERP、CRM、HR 等系统连接，打破信息孤岛，实现数据共享。\n- 多云环境管理: 在多云或混合云环境中，统一管理不同云服务之间的集成。\n- 合作伙伴集成: 与外部合作伙伴系统对接，实现供应链、物流等业务流程的协同。\n\n### 技术栈： vue3 + vite + typescript + pinia + echarts + element-plus + sass\n\n### 我的负责开发的模块：\n\n- 连接中心\n  - 我的应用\n  - 应用授权\n  - 业务流程\n  - 内置模板\n- 运维中心\n  - 运维大屏\n  - 告警管理\n- 拓展工具\n  - 文件存储\n\n项目难点：可视化流程构建，节点配置面板，参数表达式的引用处理，节点间的依赖处理，节点的拖动和复制。\n\n> 难点一：节点参数表达式的可视化构建\n\n  节点参数表达式是对节点响应参数的选取做可视化处理，当前节点可选取上游节点的响应参数作为请求参数的值。该参数的内容存在 文本 和 DOM 同时存在的输入框。常用的输入框并不能胜任。\n\n  `解决方式`：原生封装了一个类似编辑器的 `tagTextEditor` 输入框组件，该组件在项目的其他地方也多处使用。\n\n> 难点二：节点间通过参数表达式构建的依赖关系\n\n节点在切换其他应用或者器内部操作方法的时候，需要提示该节点内参数有无被引用的情况，存在则弹框提示，该节点正被哪些节点引用。并在二次确认仍切换应用或操作方法后，需对那些引用该节点的输入框中通过赋予表示引用的DOM节点红框提示该节点以更改，且文本提示，该被引用节点未变更前的信息。\n\n  `解决思路`：\n\n  - 调整原有节点数据结构，添加依赖和被依赖的映射数据结构。\n  - 采用节点唯一标识和引用次数的键值对进行记录。\n  - 结合自定义输入框中表示引用流程节点的DOM节点（携带引用流程节点的部分信息）。\n\n  `解决方式`:\n\n  - 封装 `useNodeDependence` 组合式函数统一处理该复用逻辑。\n\n> 难点三：节点的拖动和复制\n\n  `解决思路`：\n\n  - 设置节点的类型，根据类型创建专属节点数据结构。\n  - 根据粘贴的位置，对复制节点和其子节点以及插入位置上下游的节点间的父子关系更新。\n  - 清除复制粘贴后节点的所有依赖关系。\n  - 拖动类似，但需要额外处理在原位置上下游节点间的依赖关系及节点的父子关系。\n\n  `解决方式`：\n\n  - 封装 `nodeDnd` 工具容器组件，在流程及子流程节点进行包裹。\n  - 封装 `useNodeDnd` 组合式函数统一处理该复用逻辑。\n",
    "data": {
      "Created At": "8/1/2025, 4:22:23 PM",
      "Updated At": "8/4/2025, 9:34:18 AM",
      "File Name": "iPaaS",
      "Path": "src/notes/summary/iPaaS.md",
      "Tag": "summary"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "js精度问题": {
    "content": "\n# toFixed 方法无法处理的精度问题（四舍五入）\n\n解决方法：\n```js\nfunction roundFixedForES5(num, decimals) {\n  decimals = typeof decimals === 'number' ? decimals : 2\n  const EPSILON = 2.220446049250313e-16\n  const factor = 10 ** decimals\n  return Math.round((num + EPSILON) * factor) / factor\n}\n\nfunction roundFixed(num, decimals = 2) {\n  const factor = 10 ** decimals // 比如 2 位小数就是 100\n  return Math.round((num + Number.EPSILON) * factor) / factor\n}\n```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:24 PM",
      "Updated At": "8/4/2025, 9:34:25 AM",
      "File Name": "js精度问题",
      "Path": "src/notes/summary/js精度问题.md",
      "Tag": "summary"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "动态路由处理思路及问题解决": {
    "content": "\n# 动态路由处理思路及问题解决\n\n> 对于动态路由的印象中使用大多出现在根据用户权限去动态加载权限范围内的路由菜单，在我构建我的个人网站的时候，也遇到了对动态路由的相关处理。\n\n## 构建动态路由依赖的数据集\n\n这里的 `数据集` 是对项目中的 `notes` 目录下所有 `.md` 文件的信息汇总，数据结构大致如下：\n\n```ts\nexport interface NoteData {\n  'Path': string\n  'Tag': string\n  'File Name': string\n  'Created At': string\n  'Updated At': string\n}\n\nexport type NoteInfo = Record<string, { content: string, data: NoteData }>\n```\n\n这里的数据汇总有用到 [gray-matter](https://github.com/jonschlinkert/gray-matter)，用来对 `md` 文档内容头部的特殊注释进一步处理。\n\n```md\n---\nCreated At: 8/5/2025, 4:15:16 PM\nUpdated At: 8/5/2025, 4:25:30 PM\nFile Name: 动态路由处理思路及问题解决\n---\n\nxxxxx contents...\n```\n上述内容被 `gray-matter` 处理后就变成了下面数据：\n\n```json\n{\n  \"content\": \"xxxxxxx\",\n  \"data\": {\n    \"Created At\": \"8/5/2025, 4:15:16 PM\",\n    \"Updated At\": \"8/5/2025, 4:29:01 PM\",\n    \"File Name\": \"动态路由处理思路及问题解决\"\n  },\n  \"isEmpty\": false,\n  \"excerpt\": \"\"\n}\n```\n\n然后将该数据转化为另一种数据结构（即 `NoteInfo`,这里如何处理放在对 `md` 文件`增加、修改、删除`的`监听`的记录中），这样就拿到了构建动态路由所依赖的数据集。\n\n```json\n{\n  \"动态路由处理思路及问题解决\": {\n    \"content\": \"xxxx\",\n    \"data\": {\n      \"Created At\": \"8/5/2025, 4:15:16 PM\",\n      \"Updated At\": \"8/5/2025, 4:35:18 PM\",\n      \"File Name\": \"动态路由处理思路及问题解决\",\n      \"Path\": \"src/notes/summary/动态路由处理思路及问题解决.md\",\n      \"Tag\": \"summary\"\n    },\n    \"isEmpty\": false,\n    \"excerpt\": \"\"\n  }\n}\n```\n\n## 添加动态路由\n\n为了后续 **方便缓存** 相关的操作，我直接使用 `Pinia` 来处理动态路由的添加。\n\n```ts\n// /store/dynamic-routes.ts\n\nimport noteMeta from '@/records/note-meta.json'\n\nexport const useDynamicRoutes = defineStore('dynamic-routes', () => {\n  // 是否加载了动态路由\n  const hasLoadedDynamicRoutes = ref(false)\n\n  // 记录菜单合集\n  const noteMap = ref<Record<string, NoteData[]>>({})\n\n  // 上述获取到的构建动态路由依赖的数据集\n  const noteMetaJson = shallowRef(noteMeta)\n\n  const setLoadedState = (state: boolean) => {\n    hasLoadedDynamicRoutes.value = state\n  }\n\n  const setNoteMap = (val: NoteData) => {\n    noteMap.value[val.Tag] ? noteMap.value[val.Tag]?.push(val) : noteMap.value[val.Tag] = [val]\n  }\n\n  const createNoteDetailComponent = (mdRaw: string) => {\n    return defineComponent({\n      render() {\n        return h(NoteDetail, { mdRaw })\n      },\n    })\n  }\n\n  // 初始化所有动态路由页面\n  const setupNotes = async (router: Router) => {\n    for (const [title, val] of Object.entries((noteMetaJson.value))) {\n      setNoteMap(val.data)\n\n      if (router.hasRoute(title)) {\n        router.removeRoute(title)\n      }\n\n      // 添加动态路由\n      router.addRoute('Notes', {\n        path: `/notes/${val.data.Tag}/${title}`,\n        name: title,\n        component: createNoteDetailComponent(val.content),\n        props: {\n          mdRaw: val.content,\n        },\n      })\n    }\n    setLoadedState(true)\n  }\n\n  return {\n    hasLoadedDynamicRoutes,\n    noteMap,\n    setLoadedState,\n    setNoteMap,\n    setupNotes,\n  }\n})\n```\n\n然后在 notes 模块的 `onMounted` 生命周期中调用 `setupNotes`, 即可实现动态路由的添加了。\n\n## 在当前路由页面进行整个页面刷新，导致路由匹配不到的问题\n\n上述两步的操作已经是实现了动态路由的添加。但当在当前动态路由的页面，点击刷线整个页面的时候，会发现，页面直接空白了,控制台出现警告。\n\n![dynamic-routes](dynamic-route-01.png)\n\n经过询问 GPT 和 多次测试后，发现是在进入路由的时候， **动态路由** 还 **没有** 被添加到初始路由中。\n\n* 在前置 **路由钩子** 中也是 **无法** 进行 **拦截** 的，因为这个路由动态路由压根就不存在，`to` 的时候直接就报警告了。\n\n* 直接将 `setNoteMap` 函数写成异步函数，然后在 `main.ts` 文件中先加载 **动态路由**，然后在挂载 `App` 也是不行的。\n\n* 在 `routes` 中添加动态路由的占位路由，经测试是可行的。\n\n最终决定了该方案。\n\n占位路由如下：\n\n```ts\n// /router/router.config.ts\n\nconst routes = [\n  {\n    path: '/',\n    component: Layout,\n    redirect: '/components',\n    children: [\n      {\n        path: 'home',\n        component: () => import('@/view/home.vue'),\n        meta: {\n          menu: true,\n          name: 'HOME',\n        },\n      },\n      {\n        path: 'notes',\n        name: 'Notes',\n        redirect: '/notes/all',\n        children: [\n          {\n            path: 'all',\n            name: 'NoteList',\n            component: () => import('@/view/notes.vue'),\n          },\n          // 动态路由占位页面（解决动态路由无法在router初始化之前加载完，导致路由无法匹配到路由页面）\n          {\n            path: '/notes/:tag/:filename',\n            name: 'NoteLoading',\n            component: () => import('@/router/NoteLoading.vue'),\n          },\n        ],\n        meta: {\n          name: 'NOTES',\n          menu: true,\n        },\n      },\n    ],\n  },\n]\n```\n将动态路由的重载放在这个占位路由中处理。\n\n```ts\n// /router/NoteLoading.vue\n\nimport { useDynamicRoutes } from '@/stores/dynamic-routes'\n\nconst route = useRoute()\nconst router = useRouter()\nconst dynamicRoutesStore = useDynamicRoutes()\n\nfunction routeParamsMatchedError() {\n  router.replace({ name: 'NotFound' })\n  dynamicRoutesStore.setLoadedState(false)\n}\n\nfunction checkDynamicRoutes() {\n// 判断是否已加载了动态路由，若未加载，则重新加载，并通过路由参数匹配当前动态路由页面。\n  if (!dynamicRoutesStore.hasLoadedDynamicRoutes) {\n    dynamicRoutesStore.setupNotes(router)\n    const params = route.params\n    router.replace({ path: `/notes/${params.tag}/${params.filename}` })\n  }\n\n  // 判断路由参数是否正确，若不正确则跳转到 404 页面\n  const { tag, filename } = route.params\n  const tagList = dynamicRoutesStore.noteMap[`${tag}`]\n\n  if (!tagList) {\n    routeParamsMatchedError()\n    return\n  }\n\n  const hasFilename = tagList.filter(v => v['File Name'] === filename).length > 0\n  if (!hasFilename) {\n    routeParamsMatchedError()\n  }\n}\n\nonMounted(() => {\n  checkDynamicRoutes()\n})\n```\n\n以上 `checkDynamicRoutes` 方法中不仅对 **动态路由的重加载** 作了 **拦截处理**，还对 **动态路由的匹配** 做了 **兜底**，若只 **修改** 他的 **路由传参（params）的数值**，是 **不会找不到** 该路由的，而是直接 **跳转** 到 **占位路由** 页面的，因此这里对 **参数（params）** 进行了**匹配限制**，若出现 **不是** 动态路由中对应的参数值会 **跳转到404页面**。\n\n### 完。\n",
    "data": {
      "Created At": "8/5/2025, 4:15:16 PM",
      "Updated At": "8/7/2025, 4:06:49 PM",
      "File Name": "动态路由处理思路及问题解决",
      "Path": "src/notes/summary/动态路由菜单设计思路.md",
      "Tag": "summary"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "在vue组件单测中使用vue-i18n": {
    "content": "\n## 在vue组件单测中使用vue-i18n\n\n注：当前的测试工具为 [vitest](https://cn.vitest.dev/guide/)。\n\n1. 创建测试文件 `example.test.ts`\n\n    ```ts\n    import Antd from 'ant-design-vue'\n    import { createI18n, useI18n } from 'vue-i18n'\n    import ExampleForm from '../../src/components/example/index.vue'\n\n    const i18n = createI18n({\n      legacy: false, // Use Composition API style\n      locale: 'en',\n      messages: {\n        en: {\n          form: {\n            name: 'Translated Name'\n          },\n          common: {\n            select_error: 'Please select ',\n            enter_error: 'Please enter '\n          }\n        }\n      }\n    })\n\n    const wrapper = mount(\n      defineComponent({\n        components: { ExampleForm },\n        setup() {\n          const { t } = useI18n()\n          const formData = ref({ name: 'xxx' })\n          const formRef = ref<InstanceType<typeof ExampleForm>>()\n\n          const formItems = computed(() => [\n            {\n              field: 'name',\n              label: t('form.name'),\n              type: 'input',\n              required: true\n            }\n          ])\n\n          return {\n            formRef,\n            formData,\n            formItems\n          }\n        },\n        template: `\n          <ExampleForm\n            ref=\"formRef\"\n            v-model=\"formData\"\n            :form-items=\"formItems\"\n          />\n        `\n      }),\n      {\n        global: {\n          plugins: [Antd, i18n]\n        }\n      }\n    )\n\n    it('renders translated labels using vue-i18n', () => {\n      const label = wrapper.find('label')\n\n      expect(label.exists()).toBe(true)\n      expect(label.text()).toBe('Translated Name')\n    })\n    ```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:20 PM",
      "Updated At": "8/4/2025, 9:33:59 AM",
      "File Name": "在vue组件单测中使用vue-i18n",
      "Path": "src/notes/summary/在vue组件单测中使用vue-i18n.md",
      "Tag": "summary"
    },
    "isEmpty": false,
    "excerpt": ""
  },
  "节点拖动中的辅助滚动": {
    "content": "\n## 节点拖动中的辅助滚动\n\n在流程中的项目中，往往伴随着对节点的操作，今天遇到的问题就是：\n\n### <font color=red size=3>节点拖动时，滚动条的触发不灵敏，且滚动迟缓</font>\n\n这里主要讲在使用原生的 `HTML 拖放`\n\n> 用户使用鼠标选择可拖拽（draggable）元素，将元素拖拽到可放置（droppable）元素，并释放鼠标按钮以放置这些元素。\n拖拽操作期间，会有一个可拖拽元素的半透明快照跟随着鼠标指针。\n\n* 全局属性：`draggable`（让元素可拖动）`Boolean | auto` 默认 auto\n* 事件：\n\n| 事件名      | 触发时机                                                                 | 常见用途/说明                                                                                  |\n|-------------|---------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|\n| `dragstart` | 拖拽操作开始时触发（拖动源元素）                                         | 初始化拖拽数据，如设置 `dataTransfer`、添加样式等                                             |\n| `drag`      | 拖拽过程中持续触发（拖动源元素）                                         | 实时反馈拖动过程，如显示拖动轨迹、动画等（触发频率较高）                                     |\n| `dragend`   | 拖拽操作结束（释放鼠标或取消拖动）时触发（拖动源元素）                  | 清理工作，如移除样式、重置状态等                                                               |\n| `dragenter` | 拖拽目标元素进入时触发                                                   | 通常用来设置视觉反馈（如高亮目标区域），需与 `dragover` 配合才能触发 `drop`                  |\n| `dragleave` | 拖拽目标元素离开时触发                                                   | 通常用来移除 `dragenter` 设置的视觉反馈                                                        |\n| `dragover`  | 拖拽元素在目标上方移动时反复触发（必须调用 `event.preventDefault()`）   | **必须调用 `preventDefault()` 才能触发 `drop`**，可设置鼠标样式或拖拽提示                      |\n| `drop`      | 拖拽释放时触发（放在目标区域上）                                         | 获取拖拽的数据并处理，比如添加元素、更新状态等                                                |\n\n使用说明补充：\n\n* 这些事件都属于 **拖动 API（Drag and Drop API）**，只有设置了 `draggable=\"true\"` 的元素才能成为拖动源。\n* `dataTransfer` 对象在 `dragstart` 和 `drop` 事件中用于存取传递的数据。\n* 事件的监听顺序一般是：\n\n    * 拖动开始时：`dragstart` → `drag`\n    * 拖动进入目标时：`dragenter` → `dragover`（重复）→ `dragleave`（若移出）或 `drop`\n    * 拖动结束时：`dragend`\n\n## hooks 的封装\n\n```ts\n/**\n * useAutoScroll.ts\n * ------------------\n * @description\n * 提供一个用于拖拽时边缘滚动的平滑辅助工具。\n * 当鼠标靠近容器边缘时，通过 requestAnimationFrame 实现自动滚动。\n *\n * 典型应用场景如：流程图、画布、拖放列表等拖动超过容器可视区域时自动滚动。\n *\n * @usage\n * const { start, stop, updateMousePosition } = useAutoScroll(containerEl);\n * start(); // 在拖动开始时调用\n * updateMousePosition(e.clientX, e.clientY); // 在拖动过程中调用\n * stop(); // 在拖动结束后调用\n *\n *\n * @param container HTMLElement - 要滚动的容器（必须是可滚动的）\n * @param options {\n *   threshold?: number; // 鼠标离边缘多少 px 触发滚动（默认 40）\n *   maxSpeed?: number;  // 每帧最大滚动速度，单位 px（默认 12）\n * }\n *\n * @returns {\n *   start: () => void;                         // 启动自动滚动\n *   stop: () => void;                          // 停止滚动\n *   updateMousePosition: (x: number, y: number) => void; // 更新当前鼠标位置\n * }\n */\n\nimport { onBeforeUnmount } from 'vue'\n\nexport function useAutoScroll(container: HTMLElement, options = {}) {\n  // 指鼠标距离容器边缘的触发范围（单位：像素）。越大，触发越早；\n  const threshold = (options as any).threshold || 40\n\n  // 最大滚动速度（单位：px/frame）。越大，滚动越快；\n  const maxSpeed = (options as any).maxSpeed || 12\n\n  let active = false // 是否启用了自动滚动\n  let animFrame = 0 // 保存 requestAnimationFrame 的 ID\n\n  let mouseX = 0\n  let mouseY = 0\n\n  /**\n   * 更新当前鼠标位置（每次拖动时调用）\n   * @param x number - 鼠标的 clientX 坐标\n   * @param y number - 鼠标的 clientY 坐标\n   */\n  function updateMousePosition(x: number, y: number) {\n    mouseX = x\n    mouseY = y\n  }\n\n  /**\n   * 每一帧计算滚动值并执行滚动操作\n   */\n  function scrollStep() {\n    if (!active)\n      return\n\n    const rect = container.getBoundingClientRect()\n\n    const dx = getDelta(\n      mouseX,\n      rect.left,\n      rect.right,\n      container.scrollLeft,\n      container.scrollWidth,\n      container.clientWidth\n    )\n\n    const dy = getDelta(\n      mouseY,\n      rect.top,\n      rect.bottom,\n      container.scrollTop,\n      container.scrollHeight,\n      container.clientHeight\n    )\n\n    if (dx !== 0)\n      container.scrollLeft += dx\n    if (dy !== 0)\n      container.scrollTop += dy\n\n    animFrame = requestAnimationFrame(scrollStep)\n  }\n\n  /**\n   * 判断当前坐标是否靠近某一边缘，返回滚动增量\n   *\n   * @param pos number        - 鼠标在该方向上的位置（x 或 y）\n   * @param min number        - 该方向容器的起始边（left/top）\n   * @param max number        - 该方向容器的结束边（right/bottom）\n   * @param scroll number     - 当前滚动距离（scrollLeft/Top）\n   * @param scrollSize number - 容器滚动内容的总长度（scrollWidth/Height）\n   * @param clientSize number - 容器可视区域大小（clientWidth/Height）\n   *\n   * @returns number - 滚动增量（正数或负数）\n   */\n  function getDelta(\n    pos: number,\n    min: number,\n    max: number,\n    scroll: number,\n    scrollSize: number,\n    clientSize: number\n  ) {\n    if (pos - min < threshold && scroll > 0) {\n      return -getSpeed(pos - min)\n    }\n    if (max - pos < threshold && scroll < scrollSize - clientSize) {\n      return getSpeed(max - pos)\n    }\n    return 0\n  }\n\n  /**\n   * 根据距离边缘的距离，计算滚动速度\n   *\n   * @param distance number - 鼠标离边缘的像素距离\n   * @returns number - 滚动速度（px）\n   */\n  function getSpeed(distance: number) {\n    return Math.round(((threshold - distance) / threshold) * maxSpeed)\n  }\n\n  /**\n   * 启动滚动监听（在 dragstart 调用）\n   */\n  function start() {\n    if (!active) {\n      active = true\n      animFrame = requestAnimationFrame(scrollStep)\n    }\n  }\n\n  /**\n   * 停止滚动监听（在 dragend 调用）\n   */\n  function stop() {\n    active = false\n    cancelAnimationFrame(animFrame)\n  }\n\n  /**\n   * 组件卸载时自动清除动画帧，避免内存泄漏\n   */\n  onBeforeUnmount(() => {\n    stop()\n  })\n\n  return {\n    updateMousePosition,\n    start,\n    stop,\n  }\n}\n```\n\n### 使用方式：\n\n```ts\nimport { useAutoScroll } from '@/composables/useAutoScroll'\nimport { computed, onMounted, ref, shallowRef } from 'vue'\n\ntype DndType = 'DROP' | 'DRAG'\n\ninterface NodeDnd {\n  dndType: DndType\n  isOpen: boolean // 是否开放\n  // ...\n  [propName: string]: any\n}\n\nfunction useDnd(data: NodeDnd) {\n  const hovering = ref(false) // 控制预放置位置的 hover 样式（存在于连接线上）\n  const autoScroll = ref()\n\n  const dndEventMapWidthDndtype = shallowRef({\n    DROP: {\n      drop: onDrog,\n      dragover: onDragOver,\n      dragleave: onDragleave,\n    },\n    DRAG: {\n      drag: onDrag,\n      dragend: onDragEnd,\n      dragstart: onDragStart,\n    }\n  })\n\n  const dndEvents = computed(() => data.isOpen ? dndEventMapWidthDndtype(data.dndType) : {})\n\n  /**\n   * 拖动开始 - 可传递 data 中携带的节点的业务数据\n   * @param e\n   */\n  function onDragStart(e: DragEvent) {\n    e.stopPropagation()\n    autoScroll.value.start()\n  }\n\n  /**\n   * 拖动结束 - 可处理放置前的节点（对嵌套节点的不可放置到自身的校验等等）\n   * @param e\n   */\n  function onDragEnd(e: DragEvent) {\n    e.stopPropagation()\n    autoScroll.value.stop()\n  }\n\n  /**\n   * 经过可拖放节点\n   * @param e\n   */\n  function onDragOver(e: DragEvent) {\n    e.preventDefault()\n    e.dataTransfer && (e.dataTransfer!.dropEffect = 'move') // 修改经过可拖放节点时的鼠标图标\n    if (hovering.value) {\n      return\n    }\n    hovering.value = true\n  }\n\n  /**\n   * 离开可拖放节点\n   */\n  function onDragleave() {\n    hovering.value = false // 恢复鼠标于可拖放属性的 hover\n  }\n\n  /**\n   * 处理放置节点后的操作\n   *\n   * 1. 克隆被拖动的节点\n   * 2. 插入并更新流程序列\n   * 3. 更新节点上下文关联数据\n   *\n   * @param e\n   */\n  function onDrog(e: DragEvent) {\n    e.preventDefault()\n    hovering.value = false\n  }\n\n  /**\n   * 拖动过程中触发更新辅助滚动（核心）\n   * @param e\n   */\n  function onDrag(e: DragEvent) {\n    autoScroll.value.updateMousePosition(e.clientX, e.clientY)\n  }\n\n  onMounted(() => {\n    const container = document.querySelector('#flowable')! as HTMLElement\n    autoScroll.value = useAutoScroll(container)\n  })\n\n  return {\n    hovering,\n    dndEvents,\n  }\n}\n```\n",
    "data": {
      "Created At": "8/1/2025, 4:22:14 PM",
      "Updated At": "8/4/2025, 9:33:54 AM",
      "File Name": "节点拖动中的辅助滚动",
      "Path": "src/notes/summary/节点拖动中的辅助滚动.md",
      "Tag": "summary"
    },
    "isEmpty": false,
    "excerpt": ""
  }
} as const


export type NoteKey = keyof typeof notesData


export type Note = typeof notesData[NoteKey]

---
Created At: 8/5/2025, 4:15:16 PM
Updated At: 8/5/2025, 5:36:22 PM
File Name: 动态路由处理思路即问题解决
---

# 动态路由菜单设计思路

> 对于动态路由的印象中使用大多出现在根据用户权限去动态加载权限范围内的路由菜单，在我构建我的个人网站的时候，也遇到了对动态路由的相关处理。

## 构建动态路由依赖的数据集

这里的 `数据集` 是对项目中的 `notes` 目录下所有 `.md` 文件的信息汇总，数据结构大致如下：

```ts
export interface NoteData {
  'Path': string
  'Tag': string
  'File Name': string
  'Created At': string
  'Updated At': string
}

export type NoteInfo = Record<string, { content: string, data: NoteData }>
```

这里的数据汇总有用到 [gray-matter](https://github.com/jonschlinkert/gray-matter)，用来对 `md` 文档内容头部的特殊注释进一步处理。

```md
---
Created At: 8/5/2025, 4:15:16 PM
Updated At: 8/5/2025, 4:25:30 PM
File Name: 动态路由菜单设计思路
---

xxxxx contents...
```
上述内容被 `gray-matter` 处理后就变成了下面数据：

```json
{
  "content": "xxxxxxx",
  "data": {
    "Created At": "8/5/2025, 4:15:16 PM",
    "Updated At": "8/5/2025, 4:29:01 PM",
    "File Name": "动态路由菜单设计思路"
  },
  "isEmpty": false,
  "excerpt": ""
}
```

然后将该数据转化为另一种数据结构（即 `NoteInfo`,这里如何处理放在对 `md` 文件`增加、修改、删除`的`监听`的记录中），这样就拿到了构建动态路由所依赖的数据集。

```json
{
  "动态路由菜单设计思路": {
    "content": "xxxx",
    "data": {
      "Created At": "8/5/2025, 4:15:16 PM",
      "Updated At": "8/5/2025, 4:35:18 PM",
      "File Name": "动态路由菜单设计思路",
      "Path": "src/notes/summary/动态路由菜单设计思路.md",
      "Tag": "summary"
    },
    "isEmpty": false,
    "excerpt": ""
  }
}
```

## 添加动态路由

为了后续 **方便缓存** 相关的操作，我直接使用 `Pinia` 来处理动态路由的添加。

```ts
// /store/dynamic-routes.ts

import noteMeta from '@/records/note-meta.json'

export const useDynamicRoutes = defineStore('dynamic-routes', () => {
  // 是否加载了动态路由
  const hasLoadedDynamicRoutes = ref(false)

  // 记录菜单合集
  const noteMap = ref<Record<string, NoteData[]>>({})

  // 上述获取到的构建动态路由依赖的数据集
  const noteMetaJson = shallowRef(noteMeta)

  const setLoadedState = (state: boolean) => {
    hasLoadedDynamicRoutes.value = state
  }

  const setNoteMap = (val: NoteData) => {
    noteMap.value[val.Tag] ? noteMap.value[val.Tag]?.push(val) : noteMap.value[val.Tag] = [val]
  }

  const createNoteDetailComponent = (mdRaw: string) => {
    return defineComponent({
      render() {
        return h(NoteDetail, { mdRaw })
      },
    })
  }

  // 初始化所有动态路由页面
  const setupNotes = async (router: Router) => {
    for (const [title, val] of Object.entries((noteMetaJson.value))) {
      setNoteMap(val.data)

      if (router.hasRoute(title)) {
        router.removeRoute(title)
      }

      // 添加动态路由
      router.addRoute('Notes', {
        path: `/notes/${val.data.Tag}/${title}`,
        name: title,
        component: createNoteDetailComponent(val.content),
        props: {
          mdRaw: val.content,
        },
      })
    }
    setLoadedState(true)
  }

  return {
    hasLoadedDynamicRoutes,
    noteMap,
    setLoadedState,
    setNoteMap,
    setupNotes,
  }
})
```

然后在 notes 模块的 `onMounted` 生命周期中调用 `setupNotes`, 即可实现动态路由的添加了。

## 在当前路由页面进行整个页面刷新，导致路由匹配不到的问题

上述两步的操作已经是实现了动态路由的添加。但当在当前动态路由的页面，点击刷线整个页面的时候，会发现，页面直接空白了,控制台出现警告。

![dynamic-routes](dynamic-route-01.png)

经过询问 GPT 和 多次测试后，发现是在进入路由的时候， **动态路由** 还 **没有** 被添加到初始路由中。

1. 在前置 **路由钩子** 中也是 **无法** 进行 **拦截** 的，因为这个路由动态路由压根就不存在，`to` 的时候直接就报警告了。

2. 直接将 `setNoteMap` 函数写成异步函数，然后在 `main.ts` 文件中先加载 **动态路由**，然后在挂载 `App` 也是不行的。

3. 在 `routes` 中添加动态路由的占位路由，经测试是可行的。

最终决定了该方案。

占位路由如下：

```ts
// /router/router.config.ts

const routes = [
  {
    path: '/',
    component: Layout,
    redirect: '/components',
    children: [
      {
        path: 'home',
        component: () => import('@/view/home.vue'),
        meta: {
          menu: true,
          name: 'HOME',
        },
      },
      {
        path: 'notes',
        name: 'Notes',
        redirect: '/notes/all',
        children: [
          {
            path: 'all',
            name: 'NoteList',
            component: () => import('@/view/notes.vue'),
          },
          // 动态路由占位页面（解决动态路由无法在router初始化之前加载完，导致路由无法匹配到路由页面）
          {
            path: '/notes/:tag/:filename',
            name: 'NoteLoading',
            component: () => import('@/router/NoteLoading.vue'),
          },
        ],
        meta: {
          name: 'NOTES',
          menu: true,
        },
      },
    ],
  },
]
```
将动态路由的重载放在这个占位路由中处理。

```ts
// /router/NoteLoading.vue

import { useDynamicRoutes } from '@/stores/dynamic-routes'

const route = useRoute()
const router = useRouter()
const dynamicRoutesStore = useDynamicRoutes()

function routeParamsMatchedError() {
  router.replace({ name: 'NotFound' })
  dynamicRoutesStore.setLoadedState(false)
}

function checkDynamicRoutes() {
// 判断是否已加载了动态路由，若未加载，则重新加载，并通过路由参数匹配当前动态路由页面。
  if (!dynamicRoutesStore.hasLoadedDynamicRoutes) {
    dynamicRoutesStore.setupNotes(router)
    const params = route.params
    router.replace({ path: `/notes/${params.tag}/${params.filename}` })
  }

  // 判断路由参数是否正确，若不正确则跳转到 404 页面
  const { tag, filename } = route.params
  const tagList = dynamicRoutesStore.noteMap[`${tag}`]

  if (!tagList) {
    routeParamsMatchedError()
    return
  }

  const hasFilename = tagList.filter(v => v['File Name'] === filename).length > 0
  if (!hasFilename) {
    routeParamsMatchedError()
  }
}

onMounted(() => {
  checkDynamicRoutes()
})
```

以上 `checkDynamicRoutes` 方法中不仅对 **动态路由的重加载** 作了 **拦截处理**，还对 **动态路由的匹配** 做了 **兜底**，若只 **修改** 他的 **路由传参（params）的数值**，是 **不会找不到** 该路由的，而是直接 **跳转** 到 **占位路由** 页面的，因此这里对 **参数（params）** 进行了**匹配限制**，若出现 **不是** 动态路由中对应的参数值会 **跳转到404页面**。

### 完。
